namespace SourceGenerator;

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Threading;
using FunctionalDdd.CommonValueObjectGenerator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

[Generator(LanguageNames.CSharp)]
public class RequiredPartialClassGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<ClassDeclarationSyntax> requiredGuids = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (n, _) => IsSyntaxTargetForGeneration(n),
                transform: static (ctx, _) => (ClassDeclarationSyntax)ctx.Node
                ).Where(m => m is not null);

        IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndEnums
            = context.CompilationProvider.Combine(requiredGuids.Collect());

        context.RegisterSourceOutput(compilationAndEnums,
            static (spc, source) => Execute(source.Item1, source.Item2, spc));
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context)
    {
        //#if DEBUG
        //            if (!Debugger.IsAttached)
        //            {
        //                Debugger.Launch();
        //            }
        //#endif

        // I'm not sure if this is actually necessary, but `[LoggerMessage]` does it, so seems like a good idea!
        IEnumerable<ClassDeclarationSyntax> distinctClasses = classes.Distinct();

        List<RequiredPartialClassInfo> classesToGenerate = GetTypesToGenerate(compilation, distinctClasses, context.CancellationToken);

        foreach (var g in classesToGenerate)
        {
            var camelArg = g.ClassName.ToCamelCase();
            var classType = g.ClassBase switch
            {
                "RequiredGuid" => "Guid",
                "RequiredString" => "string",
                _ => "unknown"
            };

            // Build up the source code
            var source = $$"""
// <auto-generated/>
namespace {{g.NameSpace}};
using FunctionalDdd;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;

#nullable enable
[JsonConverter(typeof(ParsableJsonConverter<{{g.ClassName}}>))]
{{g.Accessibility.ToCamelCase()}} partial class {{g.ClassName}} : {{g.ClassBase}}, IParsable<{{g.ClassName}}>
{
    protected static readonly Error CannotBeEmptyError = Error.Validation("{{g.ClassName.SplitPascalCase()}} cannot be empty.", "{{g.ClassName.ToCamelCase()}}");

    private {{g.ClassName}}({{classType}} value) : base(value)
    {
    }

    public static explicit operator {{g.ClassName}}({{classType}} {{camelArg}}) => TryCreate({{camelArg}}).Value;

    public static {{g.ClassName}} Parse(string s, IFormatProvider? provider)
    {
        var r = TryCreate(s);
        if (r.IsFailure)
        {
            var val = (ValidationError)r.Error;
            throw new FormatException(val.FieldErrors[0].Details[0]);
        }
        return r.Value;
    }

    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out {{g.ClassName}} result)
    {
        var r = TryCreate(s);
        if (r.IsFailure)
        {
            result = default;
            return false;
        }

        result = r.Value;
        return true;
    }
""";

            if (g.ClassBase == "RequiredGuid")
            {
                source += $$"""

    public static {{g.ClassName}} NewUnique() => new(Guid.NewGuid());

    public static Result<{{g.ClassName}}> TryCreate(Guid? requiredGuidOrNothing)
    {
        using var activity = CommonValueObjectTrace.ActivitySource.StartActivity("{{g.ClassName}}.TryCreate");
        return requiredGuidOrNothing
            .ToResult(CannotBeEmptyError)
            .Ensure(x => x != Guid.Empty, CannotBeEmptyError)
            .Map(guid => new {{g.ClassName}}(guid));
     }

    public static Result<{{g.ClassName}}> TryCreate(string? stringOrNull)
    {
        using var activity = CommonValueObjectTrace.ActivitySource.StartActivity("{{g.ClassName}}.TryCreate");
        Guid parsedGuid = Guid.Empty;
        return stringOrNull
            .ToResult(CannotBeEmptyError)
            .Ensure(x => Guid.TryParse(x, out parsedGuid), Error.Validation("Guid should contain 32 digits with 4 dashes (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)", "{{g.ClassName.ToCamelCase()}}"))
            .Ensure(_ => parsedGuid != Guid.Empty, CannotBeEmptyError)
            .Map(guid => new {{g.ClassName}}(parsedGuid));
    }
}
""";
            }

            if (g.ClassBase == "RequiredString")
            {
                source += $$"""

    public static Result<{{g.ClassName}}> TryCreate(string? requiredStringOrNothing)
    {
        using var activity = CommonValueObjectTrace.ActivitySource.StartActivity("{{g.ClassName}}.TryCreate");
        return requiredStringOrNothing
            .EnsureNotNullOrWhiteSpace(CannotBeEmptyError)
            .Map(str => new {{g.ClassName}}(str));
    }
}
""";
            }

            context.AddSource($"{g.ClassName}.g.cs", source);
        }
    }

    private static List<RequiredPartialClassInfo> GetTypesToGenerate(Compilation compilation, IEnumerable<ClassDeclarationSyntax> classes, CancellationToken cancellationToken)
    {
        var classToGenerate = new List<RequiredPartialClassInfo>();

        foreach (var classDeclarationSyntax in classes)
        {
            // stop if we're asked to
            cancellationToken.ThrowIfCancellationRequested();

            INamedTypeSymbol? classSymbol = compilation
                .GetSemanticModel(classDeclarationSyntax.SyntaxTree)
                .GetDeclaredSymbol(classDeclarationSyntax, cancellationToken) as INamedTypeSymbol;

            if (classSymbol == null) continue;

            string className = classSymbol.Name;
            string @namespace = classSymbol.ContainingNamespace.ToDisplayString();
            string @base = classSymbol.BaseType?.Name ?? "unknown";
            string accessibility = classSymbol.DeclaredAccessibility.ToString();
            classToGenerate.Add(new RequiredPartialClassInfo(@namespace, className, @base, accessibility));
        }

        return classToGenerate;
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        if (node is ClassDeclarationSyntax c && c.BaseList != null)
        {
            var baseType = c.BaseList.Types.FirstOrDefault();
            var nameOfFirstBaseType = baseType?.Type.ToString();

            if (nameOfFirstBaseType == "RequiredString")
                return true;
            if (nameOfFirstBaseType == "RequiredGuid")
                return true;
        }

        return false;
    }
}
