namespace SourceGenerator
{
    using System.Collections.Generic;
    using System.Diagnostics;
    using FunctionalDDD.CommonValueObjectGenerator;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp.Syntax;

    [Generator]
    public class RequiredGuidGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            var requiredStrings = (context.SyntaxReceiver as RequiredStringFinder)?.RequiredStrings;
            if (requiredStrings == null) return;
            foreach (var requiredString in requiredStrings)
            {
                var label = requiredString.Identifier.Text;
                // Build up the source code
                string source = $@"// <auto-generated/>
namespace {GetNamespace(requiredString)}
{{
    using FunctionalDDD.CommonValueObjects;
    public partial class {label} : RequiredString<{label}>
    {{
        private {label}(string value) : base(value)
        {{
        }}

        public static explicit operator {label}(string {label.ToCamelCase()})
        {{
            return Create(trackingId).Value;
        }}

        public static implicit operator string({label} {label.ToCamelCase()})
        {{
            return trackingId.Value;
        }}
    }}
}}
";


                context.AddSource($"{label}.g.cs", source);
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            //#if DEBUG
            //            if (!Debugger.IsAttached)
            //            {
            //                Debugger.Launch();
            //            }
            //#endif
            Debug.WriteLine("Initalize code generator");
            context.RegisterForSyntaxNotifications(() => new RequiredStringFinder());
        }

        // determine the namespace the class/enum/struct is declared in, if any
        static string GetNamespace(BaseTypeDeclarationSyntax syntax)
        {
            // If we don't have a namespace at all we'll return an empty string
            // This accounts for the "default namespace" case
            string nameSpace = string.Empty;

            // Get the containing syntax node for the type declaration
            // (could be a nested type, for example)
            SyntaxNode? potentialNamespaceParent = syntax.Parent;

            // Keep moving "out" of nested classes etc until we get to a namespace
            // or until we run out of parents
            while (potentialNamespaceParent != null &&
                    potentialNamespaceParent is not NamespaceDeclarationSyntax
                    && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
            {
                potentialNamespaceParent = potentialNamespaceParent.Parent;
            }

            // Build up the final namespace by looping until we no longer have a namespace declaration
            if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
            {
                // We have a namespace. Use that as the type
                nameSpace = namespaceParent.Name.ToString();

                // Keep moving "out" of the namespace declarations until we 
                // run out of nested namespace declarations
                while (true)
                {
                    if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
                    {
                        break;
                    }

                    // Add the outer namespace as a prefix to the final namespace
                    nameSpace = $"{namespaceParent.Name}.{nameSpace}";
                    namespaceParent = parent;
                }
            }

            // return the final namespace
            return nameSpace;
        }

        public class RequiredStringFinder : ISyntaxReceiver
        {
            public List<ClassDeclarationSyntax> RequiredStrings { get; } = new List<ClassDeclarationSyntax>();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is ClassDeclarationSyntax classDeclSyntax && classDeclSyntax.BaseList != null)
                {
                    var baseType = classDeclSyntax.BaseList.Types.FirstOrDefault(); //  Better use this in all situations to be sure code won't break
                    var nameOfFirstBaseType = baseType?.Type.ToString();

                    if (nameOfFirstBaseType == "RequiredString<" + classDeclSyntax.Identifier.ValueText + ">")
                    {
                        RequiredStrings.Add(classDeclSyntax);
                    }
                }
            }
        }
    }
}
