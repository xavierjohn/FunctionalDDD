<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="CommonFunction.t4" #>

// <auto-generated>
//   This code was generated by a T4 template (TapErrorTs.g.tt).
///   Any changes made manually to this file will be lost when the template is regenerated.
/// </auto-generated>

namespace FunctionalDdd;
using System.Diagnostics;

/// <summary>
/// Provides TapError extension methods for Result types containing tuples (2-9 elements).
/// TapError executes side effects (logging, notifications, cleanup) on failure without modifying the result.
/// </summary>
/// <remarks>
/// <para>
/// These overloads enable error handling side effects on tuple-based results from combined operations.
/// The result is returned unchanged, making TapError ideal for error logging and monitoring in Railway Oriented Programming chains.
/// </para>
/// <para>
/// Use TapError when you need to:
/// <list type="bullet">
/// <item>Log errors and exceptions</item>
/// <item>Send error notifications or alerts</item>
/// <item>Record error metrics</item>
/// <item>Clean up resources on failure</item>
/// <item>Debug failure paths</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var result = EmailAddress.TryCreate("invalid-email")
///     .Combine(UserId.TryCreate("123"))
///     .TapError(error => _logger.LogError("Validation failed: {Error}", error.Detail))
///     .TapError(error => _metrics.RecordValidationFailure())
///     .Bind((email, userId) => CreateUser(email, userId));
/// </code>
/// </example>
public static partial class TapErrorExtensions
{
<#
  for(var i = 2; i <=9; i++) { 
#>
    /// <summary>
    /// Executes a side effect action when the <#= i #>-element tuple result is a failure.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="action">The side effect action to execute on failure.</param>
    /// <returns>The original result unchanged.</returns>
    /// <remarks>
    /// If the result is successful, the action is not executed and the success is returned unchanged.
    /// This is the inverse of Tap, executing only on the error track.
    /// </remarks>
    public static Result<(<# WriteTs(i); #>)> TapError<<# WriteTs(i); #>>(
                  this Result<(<# WriteTs(i); #>)> result,
                  Action action)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        if (result.IsFailure) {
            action();
            activity?.SetStatus(ActivityStatusCode.Error);
        }

        return result;
    }

    /// <summary>
    /// Executes a side effect action with the error when the <#= i #>-element tuple result is a failure.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="action">The side effect action to execute with the error on failure.</param>
    /// <returns>The original result unchanged.</returns>
    /// <remarks>
    /// This overload provides access to the Error object for detailed error logging or handling.
    /// </remarks>
    /// <example>
    /// <code>
    /// .TapError(error => _logger.LogError("Error: {Code} - {Detail}", error.Code, error.Detail))
    /// </code>
    /// </example>
    public static Result<(<# WriteTs(i); #>)> TapError<<# WriteTs(i); #>>(
                  this Result<(<# WriteTs(i); #>)> result,
                  Action<Error> action)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        if (result.IsFailure) {
            action(result.Error);
            activity?.SetStatus(ActivityStatusCode.Error);
        }

        return result;
    }
<#
 }
#>
}

/// <summary>
/// Provides asynchronous TapError extension methods for Result types containing tuples (2-9 elements).
/// Supports both Task and ValueTask with optional CancellationToken parameters.
/// </summary>
/// <remarks>
/// <para>
/// These methods handle various async scenarios for error handling:
/// <list type="bullet">
/// <item>Async result ? sync error handler</item>
/// <item>Sync result ? async error handler with CancellationToken</item>
/// <item>Sync result ? async error handler without CancellationToken</item>
/// <item>Async result ? async error handler with CancellationToken</item>
/// <item>Async result ? async error handler without CancellationToken</item>
/// </list>
/// </para>
/// <para>
/// Both Task and ValueTask variants are provided for performance optimization scenarios.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var result = await ValidateUserInputAsync(data)
///     .TapErrorAsync(error => _logger.LogError("Validation failed: {Error}", error))
///     .TapErrorAsync(async (error, ct) => await SendErrorNotificationAsync(error, ct), cancellationToken)
///     .BindAsync(validData => ProcessDataAsync(validData));
/// </code>
/// </example>
public static partial class TapErrorExtensionsAsync
{
<# 
  for(var i = 2; i <= 9; i++) { 
#>
    // ==================== <#= i #>-Tuple Methods ====================

    /// <summary>
    /// Executes a synchronous side effect action when an asynchronous <#= i #>-element tuple result fails.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The task representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="action">The side effect action to execute on failure.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this Task<Result<(<# WriteTs(i); #>)>> resultTask,
                  Action action)
    {
        var result = await resultTask.ConfigureAwait(false);
        return result.TapError(action);
    }

    /// <summary>
    /// Executes a synchronous side effect action with the error when an asynchronous <#= i #>-element tuple result fails.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The task representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="action">The side effect action to execute with the error on failure.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this Task<Result<(<# WriteTs(i); #>)>> resultTask,
                  Action<Error> action)
    {
        var result = await resultTask.ConfigureAwait(false);
        return result.TapError(action);
    }

    /// <summary>
    /// Executes an asynchronous side effect action when a synchronous <#= i #>-element tuple result fails.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on failure.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this Result<(<# WriteTs(i); #>)> result,
                  Func<Task> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity("tapError");
        if (result.IsFailure) {
            await func().ConfigureAwait(false);
            activity?.SetStatus(ActivityStatusCode.Error);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect action with the error when a synchronous <#= i #>-element tuple result fails.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute with the error on failure.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this Result<(<# WriteTs(i); #>)> result,
                  Func<Error, Task> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity("tapError");
        if (result.IsFailure) {
            await func(result.Error).ConfigureAwait(false);
            activity?.SetStatus(ActivityStatusCode.Error);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect action with cancellation support when a synchronous <#= i #>-element tuple result fails.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on failure.</param>
    /// <param name="cancellationToken">The cancellation token to observe.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this Result<(<# WriteTs(i); #>)> result,
                  Func<CancellationToken, Task> func,
                  CancellationToken cancellationToken = default)
    {
        using var activity = RopTrace.ActivitySource.StartActivity("tapError");
        if (result.IsFailure) {
            await func(cancellationToken).ConfigureAwait(false);
            activity?.SetStatus(ActivityStatusCode.Error);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect action with the error and cancellation support when a synchronous <#= i #>-element tuple result fails.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute with the error on failure.</param>
    /// <param name="cancellationToken">The cancellation token to observe.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this Result<(<# WriteTs(i); #>)> result,
                  Func<Error, CancellationToken, Task> func,
                  CancellationToken cancellationToken = default)
    {
        using var activity = RopTrace.ActivitySource.StartActivity("tapError");
        if (result.IsFailure) {
            await func(result.Error, cancellationToken).ConfigureAwait(false);
            activity?.SetStatus(ActivityStatusCode.Error);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect action when an asynchronous <#= i #>-element tuple result fails.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The task representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on failure.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this Task<Result<(<# WriteTs(i); #>)>> resultTask,
                  Func<Task> func)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.TapErrorAsync(func).ConfigureAwait(false);
    }

    /// <summary>
    /// Executes an asynchronous side effect action with the error when an asynchronous <#= i #>-element tuple result fails.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The task representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute with the error on failure.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this Task<Result<(<# WriteTs(i); #>)>> resultTask,
                  Func<Error, Task> func)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.TapErrorAsync(func).ConfigureAwait(false);
    }

    /// <summary>
    /// Executes an asynchronous side effect action with cancellation support when an asynchronous <#= i #>-element tuple result fails.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The task representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on failure.</param>
    /// <param name="cancellationToken">The cancellation token to observe.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this Task<Result<(<# WriteTs(i); #>)>> resultTask,
                  Func<CancellationToken, Task> func,
                  CancellationToken cancellationToken = default)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.TapErrorAsync(func, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Executes an asynchronous side effect action with the error and cancellation support when an asynchronous <#= i #>-element tuple result fails.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The task representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute with the error on failure.</param>
    /// <param name="cancellationToken">The cancellation token to observe.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this Task<Result<(<# WriteTs(i); #>)>> resultTask,
                  Func<Error, CancellationToken, Task> func,
                  CancellationToken cancellationToken = default)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.TapErrorAsync(func, cancellationToken).ConfigureAwait(false);
    }

    // ValueTask variants

    /// <summary>
    /// Executes a synchronous side effect action when an asynchronous <#= i #>-element tuple result fails (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The ValueTask representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="action">The side effect action to execute on failure.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
                  Action action)
    {
        var result = await resultTask.ConfigureAwait(false);
        return result.TapError(action);
    }

    /// <summary>
    /// Executes a synchronous side effect action with the error when an asynchronous <#= i #>-element tuple result fails (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The ValueTask representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="action">The side effect action to execute with the error on failure.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
                  Action<Error> action)
    {
        var result = await resultTask.ConfigureAwait(false);
        return result.TapError(action);
    }

    /// <summary>
    /// Executes an asynchronous side effect action when a synchronous <#= i #>-element tuple result fails (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on failure.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this Result<(<# WriteTs(i); #>)> result,
                  Func<ValueTask> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity("tapError");
        if (result.IsFailure) {
            await func().ConfigureAwait(false);
            activity?.SetStatus(ActivityStatusCode.Error);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect action with the error when a synchronous <#= i #>-element tuple result fails (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute with the error on failure.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this Result<(<# WriteTs(i); #>)> result,
                  Func<Error, ValueTask> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity("tapError");
        if (result.IsFailure) {
            await func(result.Error).ConfigureAwait(false);
            activity?.SetStatus(ActivityStatusCode.Error);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect action with cancellation support when a synchronous <#= i #>-element tuple result fails (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on failure.</param>
    /// <param name="cancellationToken">The cancellation token to observe.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this Result<(<# WriteTs(i); #>)> result,
                  Func<CancellationToken, ValueTask> func,
                  CancellationToken cancellationToken = default)
    {
        using var activity = RopTrace.ActivitySource.StartActivity("tapError");
        if (result.IsFailure) {
            await func(cancellationToken).ConfigureAwait(false);
            activity?.SetStatus(ActivityStatusCode.Error);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect action with the error and cancellation support when a synchronous <#= i #>-element tuple result fails (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute with the error on failure.</param>
    /// <param name="cancellationToken">The cancellation token to observe.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this Result<(<# WriteTs(i); #>)> result,
                  Func<Error, CancellationToken, ValueTask> func,
                  CancellationToken cancellationToken = default)
    {
        using var activity = RopTrace.ActivitySource.StartActivity("tapError");
        if (result.IsFailure) {
            await func(result.Error, cancellationToken).ConfigureAwait(false);
            activity?.SetStatus(ActivityStatusCode.Error);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect action when an asynchronous <#= i #>-element tuple result fails (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The ValueTask representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on failure.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
                  Func<ValueTask> func)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.TapErrorAsync(func).ConfigureAwait(false);
    }

    /// <summary>
    /// Executes an asynchronous side effect action with the error when an asynchronous <#= i #>-element tuple result fails (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The ValueTask representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute with the error on failure.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
                  Func<Error, ValueTask> func)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.TapErrorAsync(func).ConfigureAwait(false);
    }

    /// <summary>
    /// Executes an asynchronous side effect action with cancellation support when an asynchronous <#= i #>-element tuple result fails (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The ValueTask representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on failure.</param>
    /// <param name="cancellationToken">The cancellation token to observe.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
                  Func<CancellationToken, ValueTask> func,
                  CancellationToken cancellationToken = default)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.TapErrorAsync(func, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Executes an asynchronous side effect action with the error and cancellation support when an asynchronous <#= i #>-element tuple result fails (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The ValueTask representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute with the error on failure.</param>
    /// <param name="cancellationToken">The cancellation token to observe.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapErrorAsync<<# WriteTs(i); #>>
                  (this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
                  Func<Error, CancellationToken, ValueTask> func,
                  CancellationToken cancellationToken = default)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.TapErrorAsync(func, cancellationToken).ConfigureAwait(false);
    }
<#
 }
#>
}
