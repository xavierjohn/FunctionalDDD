<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="CommonFunction.t4" #>

// <auto-generated>
//   This code was generated by a T4 template (MapTs.g.tt).
//   Any changes made manually to this file will be lost when the template is regenerated.
// </auto-generated>

namespace FunctionalDdd;

/// <summary>
/// Provides Map extension methods for Result types containing tuples (2-9 elements).
/// These methods enable transforming tuple values from combined results without returning a Result.
/// </summary>
/// <remarks>
/// <para>
/// These overloads are generated for Result&lt;(T1, T2, ...)&gt; to support tuple-based transformations
/// after using Combine to validate multiple inputs together.
/// </para>
/// <para>
/// Use Map when your transformation function returns a plain value (not a Result).
/// Use Bind when your transformation function returns a Result.
/// </para>
/// </remarks>
public static partial class MapExtensions
{

<#
  void WriteArgs(int n) {
     Write(String.Join(", ", Enumerable.Range(1, n).Select(i => "args" + i)));
  }

  for(var i = 2; i <=9; i++) { 
#>
    /// <summary>
    /// Maps the values of a <#= i #>-element tuple result to a new value using the provided function.
    /// If the result is a failure, returns the failure without calling the function.
    /// </summary>
    /// <typeparam name="TResult">The type of the result value returned by the function.</typeparam>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The function to transform the tuple elements if the result is successful.</param>
    /// <returns>A new success Result containing the transformed value, or the original failure.</returns>
    /// <example>
    /// <code>
    /// var result = FirstName.TryCreate("John")
    ///     .Combine(LastName.TryCreate("Doe"))
<# if(i > 2) { #>
<#   for(var k = 3; k <= i; k++) { #>
    ///     .Combine(Field<#= k #>.TryCreate("value<#= k #>"))
<#   } #>
<# } #>
    ///     .Map((<# for(var j = 1; j <= i; j++) { #><#= j > 1 ? ", " : "" #>arg<#= j #><# } #>) => new Entity(<# for(var j = 1; j <= i; j++) { #><#= j > 1 ? ", " : "" #>arg<#= j #><# } #>));
    /// </code>
    /// </example>
    public static Result<TResult> Map<<# WriteTs(i); #>, TResult>(
        this Result<(<# WriteTs(i); #>)> result,
        Func<<# WriteTs(i); #>, TResult> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        if (result.IsFailure)
            return Result.Failure<TResult>(result.Error);

        var (<# WriteArgs(i); #>) = result.Value;
        return Result.Success(func(<# WriteArgs(i); #>));
    }

<#
 }
#>
}

/// <summary>
/// Provides asynchronous Map extension methods for Result types containing tuples (2-9 elements).
/// Supports both Task and ValueTask for async operations.
/// </summary>
/// <remarks>
/// <para>
/// These methods handle various async scenarios for tuple transformations.
/// Users should capture CancellationToken in their lambda closures when cancellation support is needed.
/// </para>
/// <para>
/// Both Task and ValueTask variants are provided for performance optimization scenarios.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var ct = cancellationToken;
/// var result = await emailResult
///     .Combine(userIdResult)
///     .MapAsync((email, userId) => FormatUserAsync(email, userId, ct));
/// </code>
/// </example>
public static partial class MapExtensionsAsync
{
<# 
  for(var i = 2; i <= 9; i++) { 
#>
    // ==================== <#= i #>-Tuple Methods ====================

    #region <#= i #>-Tuple Sync Result with Async Func

    /// <summary>
    /// Maps the values of a <#= i #>-element tuple result using an async function.
    /// </summary>
    public static async Task<Result<TResult>> MapAsync<<# WriteTs(i); #>, TResult>(
        this Result<(<# WriteTs(i); #>)> result,
        Func<<# WriteTs(i); #>, Task<TResult>> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        if (result.IsFailure)
            return Result.Failure<TResult>(result.Error);

        var (<# WriteArgs(i); #>) = result.Value;
        var value = await func(<# WriteArgs(i); #>).ConfigureAwait(false);
        return Result.Success(value);
    }

    /// <summary>
    /// Maps the values of a <#= i #>-element tuple result using an async ValueTask function.
    /// </summary>
    public static async ValueTask<Result<TResult>> MapAsync<<# WriteTs(i); #>, TResult>(
        this Result<(<# WriteTs(i); #>)> result,
        Func<<# WriteTs(i); #>, ValueTask<TResult>> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        if (result.IsFailure)
            return Result.Failure<TResult>(result.Error);

        var (<# WriteArgs(i); #>) = result.Value;
        var value = await func(<# WriteArgs(i); #>).ConfigureAwait(false);
        return Result.Success(value);
    }

    #endregion

    #region <#= i #>-Tuple Task Result with Sync Func

    /// <summary>
    /// Maps the values of an async <#= i #>-element tuple result using a sync function.
    /// </summary>
    public static async Task<Result<TResult>> MapAsync<<# WriteTs(i); #>, TResult>(
        this Task<Result<(<# WriteTs(i); #>)>> resultTask,
        Func<<# WriteTs(i); #>, TResult> func)
    {
        var result = await resultTask.ConfigureAwait(false);
        return result.Map(func);
    }

    /// <summary>
    /// Maps the values of an async ValueTask <#= i #>-element tuple result using a sync function.
    /// </summary>
    public static async ValueTask<Result<TResult>> MapAsync<<# WriteTs(i); #>, TResult>(
        this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
        Func<<# WriteTs(i); #>, TResult> func)
    {
        var result = await resultTask.ConfigureAwait(false);
        return result.Map(func);
    }

    #endregion

    #region <#= i #>-Tuple Task Result with Async Func

    /// <summary>
    /// Maps the values of an async <#= i #>-element tuple result using an async function.
    /// </summary>
    public static async Task<Result<TResult>> MapAsync<<# WriteTs(i); #>, TResult>(
        this Task<Result<(<# WriteTs(i); #>)>> resultTask,
        Func<<# WriteTs(i); #>, Task<TResult>> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        var result = await resultTask.ConfigureAwait(false);
        if (result.IsFailure)
            return Result.Failure<TResult>(result.Error);

        var (<# WriteArgs(i); #>) = result.Value;
        var value = await func(<# WriteArgs(i); #>).ConfigureAwait(false);
        return Result.Success(value);
    }

    /// <summary>
    /// Maps the values of an async ValueTask <#= i #>-element tuple result using an async ValueTask function.
    /// </summary>
    public static async ValueTask<Result<TResult>> MapAsync<<# WriteTs(i); #>, TResult>(
        this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
        Func<<# WriteTs(i); #>, ValueTask<TResult>> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        var result = await resultTask.ConfigureAwait(false);
        if (result.IsFailure)
            return Result.Failure<TResult>(result.Error);

        var (<# WriteArgs(i); #>) = result.Value;
        var value = await func(<# WriteArgs(i); #>).ConfigureAwait(false);
        return Result.Success(value);
    }

    #endregion

<#
  }
#>
}
