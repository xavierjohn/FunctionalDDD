<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="CommonFunction.t4" #>

// <auto-generated>
//   This code was generated by a T4 template (TapTs.g.tt).
//   Any changes made manually to this file will be lost when the template is regenerated.
// </auto-generated>

namespace FunctionalDdd;
using System.Diagnostics;

/// <summary>
/// Provides Tap extension methods for Result types containing tuples (2-9 elements).
/// Tap executes side effects (logging, metrics, notifications) on success without modifying the result value.
/// </summary>
/// <remarks>
/// <para>
/// These overloads enable side effects on tuple values from combined results.
/// The result is returned unchanged, making Tap ideal for logging and monitoring in Railway Oriented Programming chains.
/// </para>
/// <para>
/// Use Tap when you need to:
/// <list type="bullet">
/// <item>Log intermediate values during processing</item>
/// <item>Record metrics or analytics</item>
/// <item>Send notifications</item>
/// <item>Update UI or external state</item>
/// <item>Debug complex chains</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var result = EmailAddress.TryCreate("user@example.com")
///     .Combine(UserId.TryCreate("123"))
///     .Tap((email, userId) => _logger.LogInformation("Processing user {UserId} with email {Email}", userId, email))
///     .Tap((email, userId) => _metrics.RecordUserCreation())
///     .Bind((email, userId) => CreateUser(email, userId));
/// </code>
/// </example>
public static partial class TapExtensions
{
<#
  void WriteArgs(int n) {
     Write(String.Join(", ", Enumerable.Range(1, n).Select(i => "args" + i)));
  }

  for(var i = 2; i <=9; i++) { 
#>
    /// <summary>
    /// Executes a side effect action on a successful <#= i #>-element tuple result without modifying the result.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="action">The side effect action to execute on the tuple elements if successful.</param>
    /// <returns>The original result unchanged.</returns>
    /// <remarks>
    /// If the result is a failure, the action is not executed and the failure is returned unchanged.
    /// This enables safe side effects in Railway Oriented Programming chains.
    /// </remarks>
    /// <example>
    /// <code>
    /// var result = FirstName.TryCreate("John")
    ///     .Combine(LastName.TryCreate("Doe"))
<# if(i > 2) { #>
<#   for(var k = 3; k <= i; k++) { #>
    ///     .Combine(Field<#= k #>.TryCreate("value<#= k #>"))
<#   } #>
<# } #>
    ///     .Tap((<# for(var j = 1; j <= i; j++) { #><#= j > 1 ? ", " : "" #>arg<#= j #><# } #>) => _logger.LogInfo($"Values: {<#= string.Join(" + \", \" + ", Enumerable.Range(1, i).Select(x => "arg" + x)) #>}"))
    ///     .Bind((<# for(var j = 1; j <= i; j++) { #><#= j > 1 ? ", " : "" #>arg<#= j #><# } #>) => ProcessData(<# for(var j = 1; j <= i; j++) { #><#= j > 1 ? ", " : "" #>arg<#= j #><# } #>));
    /// </code>
    /// </example>
    public static Result<(<# WriteTs(i); #>)> Tap<<# WriteTs(i); #>>(
                  this Result<(<# WriteTs(i); #>)> result,
                  Action<<# WriteTs(i); #>> action)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        if (result.IsSuccess) {
            var (<# WriteArgs(i); #>) = result.Value;
            action(<# WriteArgs(i); #>);
            activity?.SetStatus(ActivityStatusCode.Ok);
        }

        return result;
    }
<#
 }
#>
}

/// <summary>
/// Provides asynchronous Tap extension methods for Result types containing tuples (2-9 elements).
/// Supports both Task and ValueTask with optional CancellationToken parameters.
/// </summary>
/// <remarks>
/// <para>
/// These methods handle various async scenarios:
/// <list type="bullet">
/// <item>Async result → sync action</item>
/// <item>Sync result → async action with CancellationToken</item>
/// <item>Sync result → async action without CancellationToken</item>
/// <item>Async result → async action with CancellationToken</item>
/// <item>Async result → async action without CancellationToken</item>
/// </list>
/// </para>
/// <para>
/// Both Task and ValueTask variants are provided for performance optimization scenarios.
/// ValueTask is preferred for hot paths where the operation frequently completes synchronously.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var result = await GetUserDataAsync(userId)
///     .TapAsync((email, name) => _logger.LogInformation("User: {Name} ({Email})", name, email))
///     .TapAsync(async (email, name, ct) => await SendWelcomeEmailAsync(email, name, ct), cancellationToken)
///     .BindAsync((email, name) => CreateUserProfileAsync(email, name));
/// </code>
/// </example>
public static partial class TapExtensionsAsync
{
<# 
  for(var i = 2; i <= 9; i++) { 
#>
    // ==================== <#= i #>-Tuple Methods ====================
    
    /// <summary>
    /// Executes a synchronous side effect action on an asynchronous <#= i #>-element tuple result.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The task representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="action">The side effect action to execute on the tuple elements if successful.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapAsync<<# WriteTs(i); #>>
                  (this Task<Result<(<# WriteTs(i); #>)>> resultTask,
                  Action<<# WriteTs(i); #>> action)
    {
        var result = await resultTask.ConfigureAwait(false);
        return result.Tap(action);
    }

    /// <summary>
    /// Executes an asynchronous side effect action on a synchronous <#= i #>-element tuple result with cancellation support.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on the tuple elements if successful.</param>
    /// <param name="cancellationToken">The cancellation token to observe.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapAsync<<# WriteTs(i); #>>
                  (this Result<(<# WriteTs(i); #>)> result,
                  Func<<# WriteTs(i); #>, CancellationToken, Task> func,
                  CancellationToken cancellationToken = default)
    {
        using var activity = RopTrace.ActivitySource.StartActivity("tap");
        if (result.IsSuccess) {
            var (<# WriteArgs(i); #>) = result.Value;
            await func(<# WriteArgs(i); #>, cancellationToken).ConfigureAwait(false);
            activity?.SetStatus(ActivityStatusCode.Ok);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect action on a synchronous <#= i #>-element tuple result without cancellation support.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on the tuple elements if successful.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapAsync<<# WriteTs(i); #>>
                  (this Result<(<# WriteTs(i); #>)> result,
                  Func<<# WriteTs(i); #>, Task> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity("tap");
        if (result.IsSuccess) {
            var (<# WriteArgs(i); #>) = result.Value;
            await func(<# WriteArgs(i); #>).ConfigureAwait(false);
            activity?.SetStatus(ActivityStatusCode.Ok);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect action on an asynchronous <#= i #>-element tuple result with cancellation support.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The task representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on the tuple elements if successful.</param>
    /// <param name="cancellationToken">The cancellation token to observe.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapAsync<<# WriteTs(i); #>>
                  (this Task<Result<(<# WriteTs(i); #>)>> resultTask,
                  Func<<# WriteTs(i); #>, CancellationToken, Task> func,
                  CancellationToken cancellationToken = default)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.TapAsync(func, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Executes an asynchronous side effect action on an asynchronous <#= i #>-element tuple result without cancellation support.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The task representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on the tuple elements if successful.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapAsync<<# WriteTs(i); #>>
                  (this Task<Result<(<# WriteTs(i); #>)>> resultTask,
                  Func<<# WriteTs(i); #>, Task> func)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.TapAsync(func).ConfigureAwait(false);
    }

    // ValueTask variants

    /// <summary>
    /// Executes a synchronous side effect action on an asynchronous <#= i #>-element tuple result (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The ValueTask representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="action">The side effect action to execute on the tuple elements if successful.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapAsync<<# WriteTs(i); #>>
                  (this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
                  Action<<# WriteTs(i); #>> action)
    {
        var result = await resultTask.ConfigureAwait(false);
        return result.Tap(action);
    }

    /// <summary>
    /// Executes an asynchronous side effect action on a synchronous <#= i #>-element tuple result with cancellation support (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on the tuple elements if successful.</param>
    /// <param name="cancellationToken">The cancellation token to observe.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapAsync<<# WriteTs(i); #>>
                  (this Result<(<# WriteTs(i); #>)> result,
                  Func<<# WriteTs(i); #>, CancellationToken, ValueTask> func,
                  CancellationToken cancellationToken = default)
    {
        using var activity = RopTrace.ActivitySource.StartActivity("tap");
        if (result.IsSuccess) {
            var (<# WriteArgs(i); #>) = result.Value;
            await func(<# WriteArgs(i); #>, cancellationToken).ConfigureAwait(false);
            activity?.SetStatus(ActivityStatusCode.Ok);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect action on a synchronous <#= i #>-element tuple result without cancellation support (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on the tuple elements if successful.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapAsync<<# WriteTs(i); #>>
                  (this Result<(<# WriteTs(i); #>)> result,
                  Func<<# WriteTs(i); #>, ValueTask> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity("tap");
        if (result.IsSuccess) {
            var (<# WriteArgs(i); #>) = result.Value;
            await func(<# WriteArgs(i); #>).ConfigureAwait(false);
            activity?.SetStatus(ActivityStatusCode.Ok);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect action on an asynchronous <#= i #>-element tuple result with cancellation support (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The ValueTask representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on the tuple elements if successful.</param>
    /// <param name="cancellationToken">The cancellation token to observe.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapAsync<<# WriteTs(i); #>>
                  (this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
                  Func<<# WriteTs(i); #>, CancellationToken, ValueTask> func,
                  CancellationToken cancellationToken = default)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.TapAsync(func, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Executes an asynchronous side effect action on an asynchronous <#= i #>-element tuple result without cancellation support (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The ValueTask representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on the tuple elements if successful.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapAsync<<# WriteTs(i); #>>
                  (this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
                  Func<<# WriteTs(i); #>, ValueTask> func)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.TapAsync(func).ConfigureAwait(false);
    }
<#
 }
#>
}
