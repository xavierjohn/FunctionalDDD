<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="CommonFunction.t4" #>

// <auto-generated>
//   This code was generated by a T4 template (AwaitTs.g.tt).
//   Any changes made manually to this file will be lost when the template is regenerated.
// </auto-generated>

namespace FunctionalDdd;

using System.Diagnostics;

<#
   void WriteTaskResult(int n) {
     Write(String.Join(", ", Enumerable.Range(1, n).Select(i => $"Task<Result<T{i}>>")));
  }
  
  void WriteTaskItem(int n) {
     Write(String.Join(", ", Enumerable.Range(1, n).Select(i => $"tasks.Item{i}")));
  }
  
  void WriteTaskItemResults(int n) {
     Write(String.Join(", ", Enumerable.Range(1, n).Select(i => $"tasks.Item{i}.Result")));
  }
#>

/// <summary>
/// Provides Await extension methods for waiting on multiple Task-wrapped Result instances and combining them.
/// These methods enable efficient parallel execution of independent async operations with Result aggregation.
/// </summary>
/// <remarks>
/// <para>
/// AwaitAsync waits for all tasks to complete using Task.WhenAll for efficient parallel execution,
/// then combines their results using the standard Combine semantics.
/// </para>
/// <para>
/// Key characteristics:
/// <list type="bullet">
/// <item>All tasks execute in parallel (not sequentially)</item>
/// <item>Waits for all tasks to complete before combining results</item>
/// <item>If any task's result fails, all errors are aggregated</item>
/// <item>More efficient than sequential await chains for independent operations</item>
/// <item>Creates distributed tracing spans for observability</item>
/// </list>
/// </para>
/// <para>
/// Use AwaitAsync when you need to:
/// <list type="bullet">
/// <item>Execute multiple independent async operations in parallel</item>
/// <item>Wait for all operations to complete before proceeding</item>
/// <item>Combine results from parallel operations</item>
/// <item>Maximize throughput for I/O-bound operations</item>
/// <item>Monitor parallel operation performance in distributed traces</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// // Execute three independent async operations in parallel
/// var result = await (
///     GetUserAsync(userId),
///     GetOrdersAsync(userId),
///     GetPreferencesAsync(userId)
/// ).AwaitAsync();
/// 
/// // All three operations run concurrently
/// // If all succeed, result contains (user, orders, preferences)
/// // If any fail, result contains all errors
/// 
/// // Then process the combined result
/// result.Match(
///     onSuccess: (user, orders, prefs) => ProcessData(user, orders, prefs),
///     onFailure: error => HandleError(error)
/// );
/// </code>
/// </example>
public static partial class AwaitExtensionsAsync
{
    /// <summary>
    /// Awaits two parallel async Result operations and combines their results.
    /// </summary>
    /// <typeparam name="T1">The type of the first result value.</typeparam>
    /// <typeparam name="T2">The type of the second result value.</typeparam>
    /// <param name="tasks">A tuple containing two tasks that produce Result values.</param>
    /// <returns>
    /// A task that represents the asynchronous operation. The task result contains:
    /// <list type="bullet">
    /// <item>A success result with a 2-element tuple if both tasks succeed</item>
    /// <item>A failure result with combined errors if either task fails</item>
    /// </list>
    /// </returns>
    /// <remarks>
    /// This method uses Task.WhenAll to execute both operations in parallel,
    /// then combines their results using standard Combine semantics.
    /// Creates a distributed tracing span to monitor parallel execution.
    /// </remarks>
    /// <example>
    /// <code>
    /// var result = await (
    ///     GetUserAsync(userId),
    ///     GetOrdersAsync(userId)
    /// ).AwaitAsync();
    /// 
    /// result.Match(
    ///     onSuccess: (user, orders) => ProcessUser(user, orders),
    ///     onFailure: error => LogError(error)
    /// );
    /// </code>
    /// </example>
    public static async Task<Result<(T1, T2)>> AwaitAsync<T1, T2>(
       this (Task<Result<T1>>, Task<Result<T2>>) tasks)
    {
       using var activity = RopTrace.ActivitySource.StartActivity("AwaitAsync");
       activity?.SetTag("parallel.task_count", 2);
       
       await Task.WhenAll(tasks.Item1, tasks.Item2);
       var result = Result.Combine(tasks.Item1.Result, tasks.Item2.Result);
       
       result.LogActivityStatus();
       return result;
    }

<# 
  for(var i = 3; i <= 9; i++) { 
#>

    /// <summary>
    /// Awaits <#= i #> parallel async Result operations and combines their results.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of the <#= GetOrdinalName(j) #> result value.</typeparam>
<# } #>
    /// <param name="tasks">A tuple containing <#= i #> tasks that produce Result values.</param>
    /// <returns>
    /// A task that represents the asynchronous operation. The task result contains:
    /// <list type="bullet">
    /// <item>A success result with a <#= i #>-element tuple if all tasks succeed</item>
    /// <item>A failure result with combined errors if any task fails</item>
    /// </list>
    /// </returns>
    /// <remarks>
    /// <para>
    /// All <#= i #> tasks execute in parallel using Task.WhenAll for maximum efficiency.
    /// Results are combined only after all tasks complete.
    /// Creates a distributed tracing span to monitor parallel execution.
    /// </para>
    /// <para>
    /// This is significantly more efficient than:
    /// <code>
    /// var r1 = await Task1(); // Wait
    /// var r2 = await Task2(); // Wait
    /// var r3 = await Task3(); // Wait sequentially
    /// </code>
    /// </para>
    /// </remarks>
    /// <example>
    /// <code>
    /// var result = await (
    ///     GetUserAsync(id),
    ///     GetOrdersAsync(id),
    ///     GetPreferencesAsync(id)<# if(i > 3) { for(var k = 4; k <= i; k++) { #>,
    ///     GetData<#= k #>Async(id)<# } } #>
    /// ).AwaitAsync();
    /// 
    /// result.Bind((<# for(var j = 1; j <= i; j++) { #><#= j > 1 ? ", " : "" #>v<#= j #><# } #>) => Process(<# for(var j = 1; j <= i; j++) { #><#= j > 1 ? ", " : "" #>v<#= j #><# } #>));
    /// </code>
    /// </example>
    public static async Task<Result<(<# WriteTs(i); #>)>> AwaitAsync<<# WriteTs(i); #>>(
        this (<# WriteTaskResult(i); #>) tasks)
    {
        using var activity = RopTrace.ActivitySource.StartActivity("AwaitAsync");
        activity?.SetTag("parallel.task_count", <#= i #>);
        
        await Task.WhenAll(<# WriteTaskItem(i); #>);
        var result = Result.Combine(<# WriteTaskItemResults(i); #>);
        
        result.LogActivityStatus();
        return result;
    }

<#
 }
#>
}

<#+
    string GetOrdinalName(int number)
    {
        return number switch
        {
            1 => "first",
            2 => "second",
            3 => "third",
            4 => "fourth",
            5 => "fifth",
            6 => "sixth",
            7 => "seventh",
            8 => "eighth",
            9 => "ninth",
            _ => number + "th"
        };
    }
#>
