<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="CommonFunction.t4" #>

// <auto-generated>
//   This code was generated by a T4 template (TapOnFailureTs.g.tt).
//   Any changes made manually to this file will be lost when the template is regenerated.
// </auto-generated>

namespace FunctionalDdd;
using System.Diagnostics;

/// <summary>
/// Provides TapOnFailure extension methods for Result types containing tuples (2-9 elements).
/// TapOnFailure executes side effects (logging, notifications, cleanup) on failure without modifying the result.
/// </summary>
/// <remarks>
/// <para>
/// These overloads enable error handling side effects on tuple-based results from combined operations.
/// The result is returned unchanged, making TapOnFailure ideal for error logging and monitoring in Railway Oriented Programming chains.
/// </para>
/// <para>
/// Use TapOnFailure when you need to:
/// <list type="bullet">
/// <item>Log errors and exceptions</item>
/// <item>Send error notifications or alerts</item>
/// <item>Record error metrics</item>
/// <item>Clean up resources on failure</item>
/// <item>Debug failure paths</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var result = EmailAddress.TryCreate("invalid-email")
///     .Combine(UserId.TryCreate("123"))
///     .TapOnFailure(error => _logger.LogError("Validation failed: {Error}", error.Detail))
///     .TapOnFailure(error => _metrics.RecordValidationFailure())
///     .Bind((email, userId) => CreateUser(email, userId));
/// </code>
/// </example>
public static partial class TapOnFailureExtensions
{
<#
  for(var i = 2; i <=9; i++) { 
#>
    /// <summary>
    /// Executes a side effect action when the <#= i #>-element tuple result is a failure.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="action">The side effect action to execute on failure.</param>
    /// <returns>The original result unchanged.</returns>
    /// <remarks>
    /// If the result is successful, the action is not executed and the success is returned unchanged.
    /// This is the inverse of Tap, executing only on the error track.
    /// </remarks>
    public static Result<(<# WriteTs(i); #>)> TapOnFailure<<# WriteTs(i); #>>(
                  this Result<(<# WriteTs(i); #>)> result,
                  Action action)
    {
        using var activity = RopTrace.ActivitySource.StartActivity(nameof(TapOnFailureExtensions.TapOnFailure));
        if (result.IsFailure) {
            action();
            activity?.SetStatus(ActivityStatusCode.Error);
        }

        return result;
    }

    /// <summary>
    /// Executes a side effect action with the error when the <#= i #>-element tuple result is a failure.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="action">The side effect action to execute with the error on failure.</param>
    /// <returns>The original result unchanged.</returns>
    /// <remarks>
    /// This overload provides access to the Error object for detailed error logging or handling.
    /// </remarks>
    /// <example>
    /// <code>
    /// .TapOnFailure(error => _logger.LogError("Error: {Code} - {Detail}", error.Code, error.Detail))
    /// </code>
    /// </example>
    public static Result<(<# WriteTs(i); #>)> TapOnFailure<<# WriteTs(i); #>>(
                  this Result<(<# WriteTs(i); #>)> result,
                  Action<Error> action)
    {
        using var activity = RopTrace.ActivitySource.StartActivity(nameof(TapOnFailureExtensions.TapOnFailure));
        if (result.IsFailure) {
            action(result.Error);
            activity?.SetStatus(ActivityStatusCode.Error);
        }

        return result;
    }
<#
 }
#>
}

/// <summary>
/// Provides asynchronous TapOnFailure extension methods for Result types containing tuples (2-9 elements).
/// Supports both Task and ValueTask for async error handling.
/// </summary>
/// <remarks>
/// <para>
/// These methods handle various async scenarios for error handling.
/// Users should capture CancellationToken in their lambda closures when cancellation support is needed.
/// </para>
/// <para>
/// Both Task and ValueTask variants are provided for performance optimization scenarios.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var ct = cancellationToken;
/// var result = await ValidateUserInputAsync(data)
///     .TapOnFailureAsync(error => _logger.LogError("Validation failed: {Error}", error))
///     .TapOnFailureAsync(error => SendErrorNotificationAsync(error, ct))
///     .BindAsync(validData => ProcessDataAsync(validData));
/// </code>
/// </example>
public static partial class TapOnFailureExtensionsAsync
{
<# 
  for(var i = 2; i <= 9; i++) { 
#>
    // ==================== <#= i #>-Tuple Methods ====================

    /// <summary>
    /// Executes a synchronous side effect action when an asynchronous <#= i #>-element tuple result fails.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The task representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="action">The side effect action to execute on failure.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapOnFailureAsync<<# WriteTs(i); #>>
                  (this Task<Result<(<# WriteTs(i); #>)>> resultTask,
                  Action action)
    {
        var result = await resultTask.ConfigureAwait(false);
        return result.TapOnFailure(action);
    }

    /// <summary>
    /// Executes a synchronous side effect action with the error when an asynchronous <#= i #>-element tuple result fails.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The task representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="action">The side effect action to execute with the error on failure.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapOnFailureAsync<<# WriteTs(i); #>>
                  (this Task<Result<(<# WriteTs(i); #>)>> resultTask,
                  Action<Error> action)
    {
        var result = await resultTask.ConfigureAwait(false);
        return result.TapOnFailure(action);
    }

    /// <summary>
    /// Executes an asynchronous side effect action when a synchronous <#= i #>-element tuple result fails.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on failure.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapOnFailureAsync<<# WriteTs(i); #>>
                  (this Result<(<# WriteTs(i); #>)> result,
                  Func<Task> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity(nameof(TapOnFailureExtensions.TapOnFailure));
        if (result.IsFailure) {
            await func().ConfigureAwait(false);
            activity?.SetStatus(ActivityStatusCode.Error);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect action with the error when a synchronous <#= i #>-element tuple result fails.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute with the error on failure.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapOnFailureAsync<<# WriteTs(i); #>>
                  (this Result<(<# WriteTs(i); #>)> result,
                  Func<Error, Task> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity(nameof(TapOnFailureExtensions.TapOnFailure));
        if (result.IsFailure) {
            await func(result.Error).ConfigureAwait(false);
            activity?.SetStatus(ActivityStatusCode.Error);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect action when an asynchronous <#= i #>-element tuple result fails.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The task representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on failure.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapOnFailureAsync<<# WriteTs(i); #>>
                  (this Task<Result<(<# WriteTs(i); #>)>> resultTask,
                  Func<Task> func)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.TapOnFailureAsync(func).ConfigureAwait(false);
    }

    /// <summary>
    /// Executes an asynchronous side effect action with the error when an asynchronous <#= i #>-element tuple result fails.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The task representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute with the error on failure.</param>
    /// <returns>A task that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async Task<Result<(<# WriteTs(i); #>)>> TapOnFailureAsync<<# WriteTs(i); #>>
                  (this Task<Result<(<# WriteTs(i); #>)>> resultTask,
                  Func<Error, Task> func)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.TapOnFailureAsync(func).ConfigureAwait(false);
    }

    // ValueTask variants

    /// <summary>
    /// Executes a synchronous side effect action when an asynchronous <#= i #>-element tuple result fails (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The ValueTask representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="action">The side effect action to execute on failure.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapOnFailureAsync<<# WriteTs(i); #>>
                  (this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
                  Action action)
    {
        var result = await resultTask.ConfigureAwait(false);
        return result.TapOnFailure(action);
    }

    /// <summary>
    /// Executes a synchronous side effect action with the error when an asynchronous <#= i #>-element tuple result fails (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The ValueTask representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="action">The side effect action to execute with the error on failure.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapOnFailureAsync<<# WriteTs(i); #>>
                  (this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
                  Action<Error> action)
    {
        var result = await resultTask.ConfigureAwait(false);
        return result.TapOnFailure(action);
    }

    /// <summary>
    /// Executes an asynchronous side effect action when a synchronous <#= i #>-element tuple result fails (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on failure.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapOnFailureAsync<<# WriteTs(i); #>>
                  (this Result<(<# WriteTs(i); #>)> result,
                  Func<ValueTask> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity(nameof(TapOnFailureExtensions.TapOnFailure));
        if (result.IsFailure) {
            await func().ConfigureAwait(false);
            activity?.SetStatus(ActivityStatusCode.Error);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect action with the error when a synchronous <#= i #>-element tuple result fails (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute with the error on failure.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapOnFailureAsync<<# WriteTs(i); #>>
                  (this Result<(<# WriteTs(i); #>)> result,
                  Func<Error, ValueTask> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity(nameof(TapOnFailureExtensions.TapOnFailure));
        if (result.IsFailure) {
            await func(result.Error).ConfigureAwait(false);
            activity?.SetStatus(ActivityStatusCode.Error);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect action when an asynchronous <#= i #>-element tuple result fails (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The ValueTask representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute on failure.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapOnFailureAsync<<# WriteTs(i); #>>
                  (this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
                  Func<ValueTask> func)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.TapOnFailureAsync(func).ConfigureAwait(false);
    }

    /// <summary>
    /// Executes an asynchronous side effect action with the error when an asynchronous <#= i #>-element tuple result fails (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="resultTask">The ValueTask representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async side effect function to execute with the error on failure.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the original result unchanged.</returns>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> TapOnFailureAsync<<# WriteTs(i); #>>
                  (this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
                  Func<Error, ValueTask> func)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.TapOnFailureAsync(func).ConfigureAwait(false);
    }
<#
 }
#>
}
