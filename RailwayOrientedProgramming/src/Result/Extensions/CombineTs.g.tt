<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="CommonFunction.t4" #>

// <auto-generated>
//   This code was generated by a T4 template (CombineTs.g.tt).
//   Any changes made manually to this file will be lost when the template is regenerated.
// </auto-generated>

namespace FunctionalDdd;
#nullable enable

/// <summary>
/// Provides Combine extension methods for aggregating multiple Result instances into tuple-based results.
/// Combine validates multiple independent operations and aggregates their errors if any fail.
/// </summary>
/// <remarks>
/// <para>
/// These overloads enable combining results to create tuples of 3-9 elements.
/// All results must succeed for the combined result to succeed.
/// If any result fails, all errors are aggregated into a single combined error.
/// </para>
/// <para>
/// Key characteristics:
/// <list type="bullet">
/// <item>All validations are executed (no short-circuiting)</item>
/// <item>ValidationErrors are merged into a single ValidationError</item>
/// <item>Mixed error types create an AggregateError</item>
/// <item>Success returns a tuple containing all values</item>
/// </list>
/// </para>
/// <para>
/// Use Combine when you need to:
/// <list type="bullet">
/// <item>Validate multiple independent inputs before processing</item>
/// <item>Collect all validation errors for user feedback</item>
/// <item>Ensure all preconditions are met before proceeding</item>
/// <item>Build complex value objects from multiple simple ones</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// // Combine 3 validations
/// var result = EmailAddress.TryCreate(email)
///     .Combine(FirstName.TryCreate(firstName))
///     .Combine(LastName.TryCreate(lastName))
///     .Bind((email, first, last) => User.Create(email, first, last));
/// 
/// // If any fail, all errors are returned
/// // If all succeed, User.Create is called with all three values
/// </code>
/// </example>
public static partial class CombineExtensions
{

<#
  void WriteT1Values(int n) {
     Write(String.Join(", ", Enumerable.Range(1, n).Select(i => $"t1.Value.Item{i}")));
  }

  for(var i = 3; i <=9; i++) { 
#>
    /// <summary>
    /// Combines a <#= i - 1 #>-element tuple result with a Unit result, preserving the original tuple on success.
    /// </summary>
<# for(var j = 1; j <= i - 1; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="t1">The result containing a <#= i - 1 #>-element tuple.</param>
    /// <param name="tc">The Unit result to combine (typically a validation with no return value).</param>
    /// <returns>
    /// If both results succeed, returns a success result with the original <#= i - 1 #>-element tuple.
    /// If either fails, returns a failure with the combined errors.
    /// </returns>
    /// <remarks>
    /// This overload is useful when you need to validate a condition without adding to the tuple.
    /// The Unit result acts as a validation gate that must pass, but contributes no value.
    /// </remarks>
    /// <example>
    /// <code>
    /// var result = FirstName.TryCreate("John")
    ///     .Combine(LastName.TryCreate("Doe"))
    ///     .Combine(EnsureExtensions.Ensure(age >= 18, Error.Validation("Must be 18+")))
    ///     .Bind((first, last) => CreateUser(first, last, age));
    /// // Age validation must pass, but age is not added to the tuple
    /// </code>
    /// </example>
    public static Result<(<# WriteTs(i - 1); #>)> Combine<<# WriteTs(i - 1); #>>(
      this Result<(<# WriteTs(i - 1); #>)> t1, Result<Unit> tc)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        Error? error = null;
        if (t1.IsFailure) error = error.Combine(t1.Error);
        if (tc.IsFailure) error = error.Combine(tc.Error);
        if (error is not null) return Result.Failure<(<# WriteTs(i - 1); #>)>(error);
        return Result.Success((<# WriteT1Values(i - 1); #>));
    }

    /// <summary>
    /// Combines a <#= i - 1 #>-element tuple result with another result to create a <#= i #>-element tuple.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the resulting tuple.</typeparam>
<# } #>
    /// <param name="t1">The result containing a <#= i - 1 #>-element tuple.</param>
    /// <param name="tc">The result to combine as the <#= i #><#= GetOrdinalSuffix(i) #> element.</param>
    /// <returns>
    /// If both results succeed, returns a success result with a <#= i #>-element tuple.
    /// If either fails, returns a failure with the combined errors.
    /// </returns>
    /// <remarks>
    /// This is the primary Combine overload for building up tuples incrementally.
    /// Each Combine call adds one more validated value to the tuple.
    /// </remarks>
    /// <example>
    /// <code>
    /// var result = EmailAddress.TryCreate(email)
    ///     .Combine(FirstName.TryCreate(firstName))
    ///     .Combine(LastName.TryCreate(lastName))
<# if(i > 3) { #>
<#   for(var k = 4; k <= i; k++) { #>
    ///     .Combine(Field<#= k #>.TryCreate("value<#= k #>"))
<#   } #>
<# } #>
    ///     .Bind((<# for(var j = 1; j <= i; j++) { #><#= j > 1 ? ", " : "" #>arg<#= j #><# } #>) => ProcessData(<# for(var j = 1; j <= i; j++) { #><#= j > 1 ? ", " : "" #>arg<#= j #><# } #>));
    /// </code>
    /// </example>
    public static Result<(<# WriteTs(i); #>)> Combine<<# WriteTs(i); #>>(
      this Result<(<# WriteTs(i - 1); #>)> t1, Result<<# Write("T" + i); #>> tc)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        Error? error = null;
        if (t1.IsFailure) error = error.Combine(t1.Error);
        if (tc.IsFailure) error = error.Combine(tc.Error);
        if (error is not null) return Result.Failure<(<# WriteTs(i); #>)>(error);
        return Result.Success((<# WriteT1Values(i - 1); #>, tc.Value));
    }

<#
 }
#>

}

/// <summary>
/// Provides async CombineAsync extension methods for aggregating tuple-based Results
/// when the left side (input) is a Task or ValueTask.
/// </summary>
public static partial class CombineExtensionsAsync
{

<#
  for(var i = 3; i <= 9; i++) {
#>
    #region <#= i - 1 #>-Tuple Task Left-Async

    /// <summary>
    /// Combine a Task-wrapped <#= i - 1 #>-tuple result with a Unit result. Left is async (Task).
    /// </summary>
    public static async Task<Result<(<# WriteTs(i - 1); #>)>> CombineAsync<<# WriteTs(i - 1); #>>(
      this Task<Result<(<# WriteTs(i - 1); #>)>> tt1, Result<Unit> tc)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        Error? error = null;
        var t1 = await tt1.ConfigureAwait(false);
        if (t1.IsFailure) error = error.Combine(t1.Error);
        if (tc.IsFailure) error = error.Combine(tc.Error);
        if (error is not null) return Result.Failure<(<# WriteTs(i - 1); #>)>(error);
        return Result.Success((<# WriteT1Values(i - 1); #>));
    }

    /// <summary>
    /// Combine a Task-wrapped <#= i - 1 #>-tuple result with another result to create a <#= i #>-tuple. Left is async (Task).
    /// </summary>
    public static async Task<Result<(<# WriteTs(i); #>)>> CombineAsync<<# WriteTs(i); #>>(
      this Task<Result<(<# WriteTs(i - 1); #>)>> tt1, Result<<# Write("T" + i); #>> tc)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        Error? error = null;
        var t1 = await tt1.ConfigureAwait(false);
        if (t1.IsFailure) error = error.Combine(t1.Error);
        if (tc.IsFailure) error = error.Combine(tc.Error);
        if (error is not null) return Result.Failure<(<# WriteTs(i); #>)>(error);
        return Result.Success((<# WriteT1Values(i - 1); #>, tc.Value));
    }

    #endregion

    #region <#= i - 1 #>-Tuple ValueTask Left-Async

    /// <summary>
    /// Combine a ValueTask-wrapped <#= i - 1 #>-tuple result with a Unit result. Left is async (ValueTask).
    /// </summary>
    public static async ValueTask<Result<(<# WriteTs(i - 1); #>)>> CombineAsync<<# WriteTs(i - 1); #>>(
      this ValueTask<Result<(<# WriteTs(i - 1); #>)>> vt1, Result<Unit> tc)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        Error? error = null;
        var t1 = await vt1.ConfigureAwait(false);
        if (t1.IsFailure) error = error.Combine(t1.Error);
        if (tc.IsFailure) error = error.Combine(tc.Error);
        if (error is not null) return Result.Failure<(<# WriteTs(i - 1); #>)>(error);
        return Result.Success((<# WriteT1Values(i - 1); #>));
    }

    /// <summary>
    /// Combine a ValueTask-wrapped <#= i - 1 #>-tuple result with another result to create a <#= i #>-tuple. Left is async (ValueTask).
    /// </summary>
    public static async ValueTask<Result<(<# WriteTs(i); #>)>> CombineAsync<<# WriteTs(i); #>>(
      this ValueTask<Result<(<# WriteTs(i - 1); #>)>> vt1, Result<<# Write("T" + i); #>> tc)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        Error? error = null;
        var t1 = await vt1.ConfigureAwait(false);
        if (t1.IsFailure) error = error.Combine(t1.Error);
        if (tc.IsFailure) error = error.Combine(tc.Error);
        if (error is not null) return Result.Failure<(<# WriteTs(i); #>)>(error);
        return Result.Success((<# WriteT1Values(i - 1); #>, tc.Value));
    }

    #endregion

<#
 }
#>

}

/// <summary>
/// Static Combine methods for combining multiple independent Result values without chaining (3-9 tuples).
/// </summary>
/// <remarks>
/// Use <c>Result.Combine(r1, r2, r3, ...)</c> when you already have individual Result variables
/// and want to combine them before error checking. Delegates to the chaining extension methods.
/// </remarks>
public readonly partial struct Result
{
<#
  for(var i = 3; i <= 9; i++) {
#>
    /// <summary>
    /// Combines <#= i #> independent <see cref="Result{TValue}"/> instances into a single <#= i #>-element tuple result.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">Type of the <#= GetOrdinalName(j) #> result value.</typeparam>
<# } #>
<# for(var j = 1; j <= i; j++) { #>
    /// <param name="r<#= j #>">The <#= GetOrdinalName(j) #> result.</param>
<# } #>
    /// <returns>
    /// A success result with a <#= i #>-element tuple if all succeed; otherwise a failure with combined errors.
    /// </returns>
    /// <example>
    /// <code>
    /// var result = Result.Combine(<# for(var j = 1; j <= i; j++) { #><#= j > 1 ? ", " : "" #>r<#= j #><# } #>)
    ///     .Bind((<# for(var j = 1; j <= i; j++) { #><#= j > 1 ? ", " : "" #>v<#= j #><# } #>) => Process(<# for(var j = 1; j <= i; j++) { #><#= j > 1 ? ", " : "" #>v<#= j #><# } #>));
    /// </code>
    /// </example>
    public static Result<(<# WriteTs(i); #>)> Combine<<# WriteTs(i); #>>(
<# for(var j = 1; j <= i; j++) { #>
        Result<T<#= j #>> r<#= j #><#= j < i ? "," : ")" #>
<# } #>
        => r1.Combine(r2)<# for(var k = 3; k <= i; k++) { #>.Combine(r<#= k #>)<# } #>;

<#
 }
#>
}

<#+
    string GetOrdinalSuffix(int number)
    {
        if (number % 100 >= 11 && number % 100 <= 13)
            return "th";
        
        return (number % 10) switch
        {
            1 => "st",
            2 => "nd",
            3 => "rd",
            _ => "th"
        };
    }

    string GetOrdinalName(int number)
    {
        return number switch
        {
            1 => "first",
            2 => "second",
            3 => "third",
            4 => "fourth",
            5 => "fifth",
            6 => "sixth",
            7 => "seventh",
            8 => "eighth",
            9 => "ninth",
            _ => number + GetOrdinalSuffix(number)
        };
    }
#>