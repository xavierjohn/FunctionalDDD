<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="CommonFunction.t4" #>

// <auto-generated>
//   This code was generated by a T4 template (CombineTs.g.tt).
//   Any changes made manually to this file will be lost when the template is regenerated.
// </auto-generated>

namespace FunctionalDdd;
#nullable enable

/// <summary>
/// Provides Combine extension methods for aggregating multiple Result instances into tuple-based results.
/// Combine validates multiple independent operations and aggregates their errors if any fail.
/// </summary>
/// <remarks>
/// <para>
/// These overloads enable combining results to create tuples of 3-9 elements.
/// All results must succeed for the combined result to succeed.
/// If any result fails, all errors are aggregated into a single combined error.
/// </para>
/// <para>
/// Key characteristics:
/// <list type="bullet">
/// <item>All validations are executed (no short-circuiting)</item>
/// <item>ValidationErrors are merged into a single ValidationError</item>
/// <item>Mixed error types create an AggregateError</item>
/// <item>Success returns a tuple containing all values</item>
/// </list>
/// </para>
/// <para>
/// Use Combine when you need to:
/// <list type="bullet">
/// <item>Validate multiple independent inputs before processing</item>
/// <item>Collect all validation errors for user feedback</item>
/// <item>Ensure all preconditions are met before proceeding</item>
/// <item>Build complex value objects from multiple simple ones</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// // Combine 3 validations
/// var result = EmailAddress.TryCreate(email)
///     .Combine(FirstName.TryCreate(firstName))
///     .Combine(LastName.TryCreate(lastName))
///     .Bind((email, first, last) => User.Create(email, first, last));
/// 
/// // If any fail, all errors are returned
/// // If all succeed, User.Create is called with all three values
/// </code>
/// </example>
public static partial class CombineExtensions
{

<#
  void WriteT1Values(int n) {
     Write(String.Join(", ", Enumerable.Range(1, n).Select(i => $"t1.Value.Item{i}")));
  }
  
  void WriteResultT(int n) {
     Write(String.Join(", ", Enumerable.Range(1, n).Select(i => $"Result<T{i}> t{i}")));
  }

  void WriteAddFailure(int n) {
    for(var i = 1; i <= n; i++)
        WriteLine($"if (t{i}.IsFailure) error = error.Combine(t{i}.Error);");
  }

  void WriteTValues(int n) {
     Write(String.Join(", ", Enumerable.Range(1, n).Select(i => $"t{i}.Value")));
  }

  for(var i = 3; i <=9; i++) { 
#>
    /// <summary>
    /// Combines a <#= i - 1 #>-element tuple result with a Unit result, preserving the original tuple on success.
    /// </summary>
<# for(var j = 1; j <= i - 1; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="t1">The result containing a <#= i - 1 #>-element tuple.</param>
    /// <param name="tc">The Unit result to combine (typically a validation with no return value).</param>
    /// <returns>
    /// If both results succeed, returns a success result with the original <#= i - 1 #>-element tuple.
    /// If either fails, returns a failure with the combined errors.
    /// </returns>
    /// <remarks>
    /// This overload is useful when you need to validate a condition without adding to the tuple.
    /// The Unit result acts as a validation gate that must pass, but contributes no value.
    /// </remarks>
    /// <example>
    /// <code>
    /// var result = FirstName.TryCreate("John")
    ///     .Combine(LastName.TryCreate("Doe"))
    ///     .Combine(EnsureExtensions.Ensure(age >= 18, Error.Validation("Must be 18+")))
    ///     .Bind((first, last) => CreateUser(first, last, age));
    /// // Age validation must pass, but age is not added to the tuple
    /// </code>
    /// </example>
    public static Result<(<# WriteTs(i - 1); #>)> Combine<<# WriteTs(i - 1); #>>(
      this Result<(<# WriteTs(i - 1); #>)> t1, Result<Unit> tc)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        Error? error = null;
        if (t1.IsFailure) error = error.Combine(t1.Error);
        if (tc.IsFailure) error = error.Combine(tc.Error);
        if (error is not null) return Result.Failure<(<# WriteTs(i - 1); #>)>(error);
        return Result.Success((<# WriteT1Values(i - 1); #>));
    }

    /// <summary>
    /// Combines a <#= i - 1 #>-element tuple result with another result to create a <#= i #>-element tuple.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the resulting tuple.</typeparam>
<# } #>
    /// <param name="t1">The result containing a <#= i - 1 #>-element tuple.</param>
    /// <param name="tc">The result to combine as the <#= i #><#= GetOrdinalSuffix(i) #> element.</param>
    /// <returns>
    /// If both results succeed, returns a success result with a <#= i #>-element tuple.
    /// If either fails, returns a failure with the combined errors.
    /// </returns>
    /// <remarks>
    /// This is the primary Combine overload for building up tuples incrementally.
    /// Each Combine call adds one more validated value to the tuple.
    /// </remarks>
    /// <example>
    /// <code>
    /// var result = EmailAddress.TryCreate(email)
    ///     .Combine(FirstName.TryCreate(firstName))
    ///     .Combine(LastName.TryCreate(lastName))
<# if(i > 3) { #>
<#   for(var k = 4; k <= i; k++) { #>
    ///     .Combine(Field<#= k #>.TryCreate("value<#= k #>"))
<#   } #>
<# } #>
    ///     .Bind((<# for(var j = 1; j <= i; j++) { #><#= j > 1 ? ", " : "" #>arg<#= j #><# } #>) => ProcessData(<# for(var j = 1; j <= i; j++) { #><#= j > 1 ? ", " : "" #>arg<#= j #><# } #>));
    /// </code>
    /// </example>
    public static Result<(<# WriteTs(i); #>)> Combine<<# WriteTs(i); #>>(
      this Result<(<# WriteTs(i - 1); #>)> t1, Result<<# Write("T" + i); #>> tc)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        Error? error = null;
        if (t1.IsFailure) error = error.Combine(t1.Error);
        if (tc.IsFailure) error = error.Combine(tc.Error);
        if (error is not null) return Result.Failure<(<# WriteTs(i); #>)>(error);
        return Result.Success((<# WriteT1Values(i - 1); #>, tc.Value));
    }

    /// <summary>
    /// Combines <#= i #> independent results into a single <#= i #>-element tuple result.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the resulting tuple.</typeparam>
<# } #>
<# for(var j = 1; j <= i; j++) { #>
    /// <param name="t<#= j #>">The <#= GetOrdinalName(j) #> result to combine.</param>
<# } #>
    /// <returns>
    /// If all results succeed, returns a success result with a <#= i #>-element tuple containing all values.
    /// If any result fails, returns a failure with all errors combined.
    /// </returns>
    /// <remarks>
    /// This overload allows combining <#= i #> results in a single call rather than chaining.
    /// Useful when all results are available simultaneously.
    /// </remarks>
    /// <example>
    /// <code>
    /// var result = CombineExtensions.Combine(
    ///     EmailAddress.TryCreate(email),
    ///     FirstName.TryCreate(firstName),
    ///     LastName.TryCreate(lastName)<# if(i > 3) { for(var k = 4; k <= i; k++) { #>,
    ///     Field<#= k #>.TryCreate("value<#= k #>")<# } } #>);
    /// </code>
    /// </example>
    public static Result<(<# WriteTs(i); #>)> Combine<<# WriteTs(i); #>>(
       this <# WriteResultT(i); #>)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        Error? error = null;
        <# WriteAddFailure(i); #>

        if (error is not null) return Result.Failure<(<# WriteTs(i); #>)>(error);
        return Result.Success((<# WriteTValues(i); #>));
    }

<#
 }
#>

}

<#+
    string GetOrdinalSuffix(int number)
    {
        if (number % 100 >= 11 && number % 100 <= 13)
            return "th";
        
        return (number % 10) switch
        {
            1 => "st",
            2 => "nd",
            3 => "rd",
            _ => "th"
        };
    }

    string GetOrdinalName(int number)
    {
        return number switch
        {
            1 => "first",
            2 => "second",
            3 => "third",
            4 => "fourth",
            5 => "fifth",
            6 => "sixth",
            7 => "seventh",
            8 => "eighth",
            9 => "ninth",
            _ => number + GetOrdinalSuffix(number)
        };
    }
#>