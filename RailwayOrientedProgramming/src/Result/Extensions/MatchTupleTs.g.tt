<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    const int MinTupleSize = 2;
    const int MaxTupleSize = 5;
    
    string GetTypeParams(int count) => string.Join(", ", Enumerable.Range(1, count).Select(i => $"T{i}"));
    string GetTupleType(int count) => $"({GetTypeParams(count)})";
    string GetValueParams(int count) => string.Join(", ", Enumerable.Range(1, count).Select(i => $"v{i}"));
    string GetFuncParams(int count) => string.Join(", ", Enumerable.Range(1, count).Select(i => $"T{i}"));
    string GetDestructure(int count) => $"var ({GetValueParams(count)}) = result.Value;";
#>
namespace FunctionalDdd;

using System.Diagnostics;
using System.Threading.Tasks;

/// <summary>
/// Pattern matching helpers for Result with tuple destructuring support.
/// Allows matching on Result&lt;(T1, T2, ...)&gt; with automatic tuple destructuring.
/// </summary>
/// <remarks>
/// This file is auto-generated by MatchTuple.tt. Do not modify directly.
/// </remarks>
public static class MatchTupleExtensions
{
<# for (int tupleSize = MinTupleSize; tupleSize <= MaxTupleSize; tupleSize++) { 
    string typeParams = GetTypeParams(tupleSize);
    string tupleType = GetTupleType(tupleSize);
    string valueParams = GetValueParams(tupleSize);
    string funcParams = GetFuncParams(tupleSize);
    string destructure = GetDestructure(tupleSize);
#>
    /// <summary>
    /// Matches on a Result containing a <#= tupleSize #>-tuple, destructuring the tuple values.
    /// </summary>
<# for (int i = 1; i <= tupleSize; i++) { #>
    /// <typeparam name="T<#= i #>">Type of the <#= GetOrdinal(i) #> tuple element.</typeparam>
<# } #>
    /// <typeparam name="TOut">Type of the output.</typeparam>
    /// <param name="result">The result to match on.</param>
    /// <param name="onSuccess">Function to execute on success, receiving destructured tuple values.</param>
    /// <param name="onFailure">Function to execute on failure.</param>
    /// <returns>The output from either the success or failure function.</returns>
    public static TOut Match<<#= typeParams #>, TOut>(
        this Result<<#= tupleType #>> result,
        Func<<#= funcParams #>, TOut> onSuccess,
        Func<Error, TOut> onFailure)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        if (result.IsSuccess)
        {
            activity?.SetStatus(ActivityStatusCode.Ok);
            <#= destructure #>
            return onSuccess(<#= valueParams #>);
        }
        else
        {
            activity?.SetStatus(ActivityStatusCode.Error);
            return onFailure(result.Error);
        }
    }

<# } #>
<# for (int tupleSize = MinTupleSize; tupleSize <= MaxTupleSize; tupleSize++) { 
    string typeParams = GetTypeParams(tupleSize);
    string tupleType = GetTupleType(tupleSize);
    string valueParams = GetValueParams(tupleSize);
    string funcParams = GetFuncParams(tupleSize);
    string destructure = GetDestructure(tupleSize);
#>
    /// <summary>
    /// Switches on a Result containing a <#= tupleSize #>-tuple, destructuring the tuple values.
    /// </summary>
<# for (int i = 1; i <= tupleSize; i++) { #>
    /// <typeparam name="T<#= i #>">Type of the <#= GetOrdinal(i) #> tuple element.</typeparam>
<# } #>
    /// <param name="result">The result to switch on.</param>
    /// <param name="onSuccess">Action to execute on success, receiving destructured tuple values.</param>
    /// <param name="onFailure">Action to execute on failure.</param>
    public static void Switch<<#= typeParams #>>(
        this Result<<#= tupleType #>> result,
        Action<<#= funcParams #>> onSuccess,
        Action<Error> onFailure)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        if (result.IsSuccess)
        {
            activity?.SetStatus(ActivityStatusCode.Ok);
            <#= destructure #>
            onSuccess(<#= valueParams #>);
        }
        else
        {
            activity?.SetStatus(ActivityStatusCode.Error);
            onFailure(result.Error);
        }
    }

<# } #>
}

/// <summary>
/// Asynchronous pattern matching helpers for Result with tuple destructuring support.
/// </summary>
/// <remarks>
/// This file is auto-generated by MatchTuple.tt. Do not modify directly.
/// </remarks>
public static class MatchTupleExtensionsAsync
{
<# for (int tupleSize = MinTupleSize; tupleSize <= MaxTupleSize; tupleSize++) { 
    string typeParams = GetTypeParams(tupleSize);
    string tupleType = GetTupleType(tupleSize);
    string valueParams = GetValueParams(tupleSize);
    string funcParams = GetFuncParams(tupleSize);
#>
    /// <summary>
    /// Asynchronously matches on a Result containing a <#= tupleSize #>-tuple, destructuring the tuple values.
    /// </summary>
<# for (int i = 1; i <= tupleSize; i++) { #>
    /// <typeparam name="T<#= i #>">Type of the <#= GetOrdinal(i) #> tuple element.</typeparam>
<# } #>
    /// <typeparam name="TOut">Type of the output.</typeparam>
    /// <param name="resultTask">The task representing the result to match on.</param>
    /// <param name="onSuccess">Function to execute on success, receiving destructured tuple values.</param>
    /// <param name="onFailure">Function to execute on failure.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the output from either the success or failure function.</returns>
    public static async Task<TOut> MatchAsync<<#= typeParams #>, TOut>(
        this Task<Result<<#= tupleType #>>> resultTask,
        Func<<#= funcParams #>, TOut> onSuccess,
        Func<Error, TOut> onFailure)
    {
        var result = await resultTask.ConfigureAwait(false);
        return result.Match(onSuccess, onFailure);
    }

<# } #>
<# for (int tupleSize = MinTupleSize; tupleSize <= MaxTupleSize; tupleSize++) { 
    string typeParams = GetTypeParams(tupleSize);
    string tupleType = GetTupleType(tupleSize);
    string valueParams = GetValueParams(tupleSize);
    string funcParams = GetFuncParams(tupleSize);
    string destructure = GetDestructure(tupleSize);
#>
    /// <summary>
    /// Matches on a Result containing a <#= tupleSize #>-tuple with async handlers, destructuring the tuple values.
    /// </summary>
<# for (int i = 1; i <= tupleSize; i++) { #>
    /// <typeparam name="T<#= i #>">Type of the <#= GetOrdinal(i) #> tuple element.</typeparam>
<# } #>
    /// <typeparam name="TOut">Type of the output.</typeparam>
    /// <param name="result">The result to match on.</param>
    /// <param name="onSuccess">Async function to execute on success, receiving destructured tuple values.</param>
    /// <param name="onFailure">Async function to execute on failure.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the output from either the success or failure function.</returns>
    public static async Task<TOut> MatchAsync<<#= typeParams #>, TOut>(
        this Result<<#= tupleType #>> result,
        Func<<#= funcParams #>, Task<TOut>> onSuccess,
        Func<Error, Task<TOut>> onFailure)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        if (result.IsSuccess)
        {
            activity?.SetStatus(ActivityStatusCode.Ok);
            <#= destructure #>
            return await onSuccess(<#= valueParams #>).ConfigureAwait(false);
        }
        else
        {
            activity?.SetStatus(ActivityStatusCode.Error);
            return await onFailure(result.Error).ConfigureAwait(false);
        }
    }

<# } #>
<# for (int tupleSize = MinTupleSize; tupleSize <= MaxTupleSize; tupleSize++) { 
    string typeParams = GetTypeParams(tupleSize);
    string tupleType = GetTupleType(tupleSize);
    string valueParams = GetValueParams(tupleSize);
    string funcParams = GetFuncParams(tupleSize);
    string destructure = GetDestructure(tupleSize);
#>
    /// <summary>
    /// Matches on a Result containing a <#= tupleSize #>-tuple with async handlers and CancellationToken, destructuring the tuple values.
    /// </summary>
<# for (int i = 1; i <= tupleSize; i++) { #>
    /// <typeparam name="T<#= i #>">Type of the <#= GetOrdinal(i) #> tuple element.</typeparam>
<# } #>
    /// <typeparam name="TOut">Type of the output.</typeparam>
    /// <param name="result">The result to match on.</param>
    /// <param name="onSuccess">Async function to execute on success, receiving destructured tuple values.</param>
    /// <param name="onFailure">Async function to execute on failure.</param>
    /// <param name="cancellationToken">The cancellation token to observe.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the output from either the success or failure function.</returns>
    public static async Task<TOut> MatchAsync<<#= typeParams #>, TOut>(
        this Result<<#= tupleType #>> result,
        Func<<#= funcParams #>, CancellationToken, Task<TOut>> onSuccess,
        Func<Error, CancellationToken, Task<TOut>> onFailure,
        CancellationToken cancellationToken = default)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        if (result.IsSuccess)
        {
            activity?.SetStatus(ActivityStatusCode.Ok);
            <#= destructure #>
            return await onSuccess(<#= valueParams #>, cancellationToken).ConfigureAwait(false);
        }
        else
        {
            activity?.SetStatus(ActivityStatusCode.Error);
            return await onFailure(result.Error, cancellationToken).ConfigureAwait(false);
        }
    }

<# } #>
<# for (int tupleSize = MinTupleSize; tupleSize <= MaxTupleSize; tupleSize++) { 
    string typeParams = GetTypeParams(tupleSize);
    string tupleType = GetTupleType(tupleSize);
    string funcParams = GetFuncParams(tupleSize);
#>
    /// <summary>
    /// Asynchronously matches on a Result containing a <#= tupleSize #>-tuple with async handlers and CancellationToken, destructuring the tuple values.
    /// </summary>
<# for (int i = 1; i <= tupleSize; i++) { #>
    /// <typeparam name="T<#= i #>">Type of the <#= GetOrdinal(i) #> tuple element.</typeparam>
<# } #>
    /// <typeparam name="TOut">Type of the output.</typeparam>
    /// <param name="resultTask">The task representing the result to match on.</param>
    /// <param name="onSuccess">Async function to execute on success, receiving destructured tuple values.</param>
    /// <param name="onFailure">Async function to execute on failure.</param>
    /// <param name="cancellationToken">The cancellation token to observe.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the output from either the success or failure function.</returns>
    public static async Task<TOut> MatchAsync<<#= typeParams #>, TOut>(
        this Task<Result<<#= tupleType #>>> resultTask,
        Func<<#= funcParams #>, CancellationToken, Task<TOut>> onSuccess,
        Func<Error, CancellationToken, Task<TOut>> onFailure,
        CancellationToken cancellationToken = default)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.MatchAsync(onSuccess, onFailure, cancellationToken).ConfigureAwait(false);
    }

<# } #>
<# for (int tupleSize = MinTupleSize; tupleSize <= MaxTupleSize; tupleSize++) { 
    string typeParams = GetTypeParams(tupleSize);
    string tupleType = GetTupleType(tupleSize);
    string valueParams = GetValueParams(tupleSize);
    string funcParams = GetFuncParams(tupleSize);
    string destructure = GetDestructure(tupleSize);
#>
    /// <summary>
    /// Asynchronously switches on a Result containing a <#= tupleSize #>-tuple, destructuring the tuple values.
    /// </summary>
<# for (int i = 1; i <= tupleSize; i++) { #>
    /// <typeparam name="T<#= i #>">Type of the <#= GetOrdinal(i) #> tuple element.</typeparam>
<# } #>
    /// <param name="resultTask">The task representing the result to switch on.</param>
    /// <param name="onSuccess">Async action to execute on success, receiving destructured tuple values.</param>
    /// <param name="onFailure">Async action to execute on failure.</param>
    /// <param name="cancellationToken">The cancellation token to observe.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public static async Task SwitchAsync<<#= typeParams #>>(
        this Task<Result<<#= tupleType #>>> resultTask,
        Func<<#= funcParams #>, CancellationToken, Task> onSuccess,
        Func<Error, CancellationToken, Task> onFailure,
        CancellationToken cancellationToken = default)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        var result = await resultTask.ConfigureAwait(false);
        if (result.IsSuccess)
        {
            activity?.SetStatus(ActivityStatusCode.Ok);
            <#= destructure #>
            await onSuccess(<#= valueParams #>, cancellationToken).ConfigureAwait(false);
        }
        else
        {
            activity?.SetStatus(ActivityStatusCode.Error);
            await onFailure(result.Error, cancellationToken).ConfigureAwait(false);
        }
    }

<# } #>
}
<#+
    string GetOrdinal(int number)
    {
        string[] ordinals = { "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth" };
        return number <= ordinals.Length ? ordinals[number - 1] : $"{number}th";
    }
#>
