<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    const int MinTupleSize = 2;
    const int MaxTupleSize = 5;
    
    string GetTypeParams(int count) => string.Join(", ", Enumerable.Range(1, count).Select(i => $"T{i}"));
    string GetTupleType(int count) => $"({GetTypeParams(count)})";
    string GetValueParams(int count) => string.Join(", ", Enumerable.Range(1, count).Select(i => $"v{i}"));
    string GetFuncParams(int count) => string.Join(", ", Enumerable.Range(1, count).Select(i => $"T{i}"));
    string GetDestructure(int count) => $"var ({GetValueParams(count)}) = result.Value;";
#>

// <auto-generated>
//   This code was generated by a T4 template (MatchTupleTs.g.tt).
//   Any changes made manually to this file will be lost when the template is regenerated.
// </auto-generated>

namespace FunctionalDdd;

using System.Diagnostics;
using System.Threading.Tasks;

/// <summary>
/// Provides pattern matching extension methods for Result types containing tuples (2-5 elements) with automatic destructuring.
/// Match enables handling both success and failure cases inline with clean, readable code.
/// </summary>
/// <remarks>
/// <para>
/// These overloads automatically destructure tuple values, eliminating the need to manually extract tuple elements.
/// This makes pattern matching on combined results more ergonomic and type-safe.
/// </para>
/// <para>
/// Key features:
/// <list type="bullet">
/// <item>Automatic tuple destructuring - no manual element access needed</item>
/// <item>Type-safe handling of both success and failure paths</item>
/// <item>Compile-time verification of tuple element types</item>
/// <item>Clean, readable syntax for complex result handling</item>
/// </list>
/// </para>
/// <para>
/// Use Match when you need to:
/// <list type="bullet">
/// <item>Convert Result to another type (e.g., HTTP response, DTO)</item>
/// <item>Handle both success and failure paths explicitly</item>
/// <item>Work with tuple values from Combine operations</item>
/// <item>Transform results at API boundaries</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var response = EmailAddress.TryCreate(email)
///     .Combine(FirstName.TryCreate(firstName))
///     .Match(
///         onSuccess: (email, firstName) => Ok(new UserDto { Email = email, Name = firstName }),
///         onFailure: error => BadRequest(error.Detail)
///     );
/// </code>
/// </example>
[DebuggerStepThrough]
public static class MatchTupleExtensions
{
<# for (int tupleSize = MinTupleSize; tupleSize <= MaxTupleSize; tupleSize++) { 
    string typeParams = GetTypeParams(tupleSize);
    string tupleType = GetTupleType(tupleSize);
    string valueParams = GetValueParams(tupleSize);
    string funcParams = GetFuncParams(tupleSize);
    string destructure = GetDestructure(tupleSize);
#>
    /// <summary>
    /// Matches on a Result containing a <#= tupleSize #>-element tuple, automatically destructuring the tuple values.
    /// </summary>
<# for (int i = 1; i <= tupleSize; i++) { #>
    /// <typeparam name="T<#= i #>">The type of the <#= GetOrdinal(i) #> tuple element.</typeparam>
<# } #>
    /// <typeparam name="TOut">The type of the output from either function.</typeparam>
    /// <param name="result">The result to match on.</param>
    /// <param name="onSuccess">Function to execute on success, receiving <#= tupleSize #> destructured tuple values as separate parameters.</param>
    /// <param name="onFailure">Function to execute on failure, receiving the error.</param>
    /// <returns>The output from either the success or failure function.</returns>
    /// <remarks>
    /// The tuple is automatically destructured, so you receive individual values rather than accessing tuple members.
    /// This provides cleaner, more readable code compared to manual tuple access.
    /// </remarks>
    /// <example>
    /// <code>
    /// var greeting = FirstName.TryCreate("John")
    ///     .Combine(LastName.TryCreate("Doe"))<# if(tupleSize > 2) { for(int k = 3; k <= tupleSize; k++) { #>
    ///     .Combine(Field<#= k #>.TryCreate("value<#= k #>"))<# } } #>
    ///     .Match(
    ///         onSuccess: (<#= string.Join(", ", Enumerable.Range(1, tupleSize).Select(i => $"v{i}")) #>) => $"Hello, {<#= string.Join(" + \", \" + ", Enumerable.Range(1, tupleSize).Select(i => $"v{i}")) #>}!",
    ///         onFailure: error => $"Error: {error.Detail}"
    ///     );
    /// </code>
    /// </example>
    public static TOut Match<<#= typeParams #>, TOut>(
        this Result<<#= tupleType #>> result,
        Func<<#= funcParams #>, TOut> onSuccess,
        Func<Error, TOut> onFailure)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        if (result.IsSuccess)
        {
            activity?.SetStatus(ActivityStatusCode.Ok);
            <#= destructure #>
            return onSuccess(<#= valueParams #>);
        }
        else
        {
            activity?.SetStatus(ActivityStatusCode.Error);
            return onFailure(result.Error);
        }
    }

<# } #>
<# for (int tupleSize = MinTupleSize; tupleSize <= MaxTupleSize; tupleSize++) { 
    string typeParams = GetTypeParams(tupleSize);
    string tupleType = GetTupleType(tupleSize);
    string valueParams = GetValueParams(tupleSize);
    string funcParams = GetFuncParams(tupleSize);
    string destructure = GetDestructure(tupleSize);
#>
    /// <summary>
    /// Switches on a Result containing a <#= tupleSize #>-element tuple, automatically destructuring the tuple values for side effects.
    /// </summary>
<# for (int i = 1; i <= tupleSize; i++) { #>
    /// <typeparam name="T<#= i #>">The type of the <#= GetOrdinal(i) #> tuple element.</typeparam>
<# } #>
    /// <param name="result">The result to switch on.</param>
    /// <param name="onSuccess">Action to execute on success, receiving <#= tupleSize #> destructured tuple values as separate parameters.</param>
    /// <param name="onFailure">Action to execute on failure, receiving the error.</param>
    /// <remarks>
    /// Unlike Match which returns a value, Switch executes actions for side effects only.
    /// Use Switch when you need to perform operations but don't need to return a result.
    /// </remarks>
    /// <example>
    /// <code>
    /// FirstName.TryCreate("John")
    ///     .Combine(LastName.TryCreate("Doe"))<# if(tupleSize > 2) { for(int k = 3; k <= tupleSize; k++) { #>
    ///     .Combine(Field<#= k #>.TryCreate("value<#= k #>"))<# } } #>
    ///     .Switch(
    ///         onSuccess: (<#= string.Join(", ", Enumerable.Range(1, tupleSize).Select(i => $"v{i}")) #>) => Console.WriteLine($"Success: {<#= string.Join(" + \", \" + ", Enumerable.Range(1, tupleSize).Select(i => $"v{i}")) #>}"),
    ///         onFailure: error => Console.WriteLine($"Error: {error.Detail}")
    ///     );
    /// </code>
    /// </example>
    public static void Switch<<#= typeParams #>>(
        this Result<<#= tupleType #>> result,
        Action<<#= funcParams #>> onSuccess,
        Action<Error> onFailure)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        if (result.IsSuccess)
        {
            activity?.SetStatus(ActivityStatusCode.Ok);
            <#= destructure #>
            onSuccess(<#= valueParams #>);
        }
        else
        {
            activity?.SetStatus(ActivityStatusCode.Error);
            onFailure(result.Error);
        }
    }

<# } #>
}

/// <summary>
/// Provides asynchronous pattern matching extension methods for Result types containing tuples (2-5 elements).
/// Supports both Task and ValueTask for async pattern matching.
/// </summary>
/// <remarks>
/// <para>
/// These methods handle various async scenarios with automatic tuple destructuring.
/// Users should capture CancellationToken in their lambda closures when cancellation support is needed.
/// </para>
/// <para>
/// All variants automatically destructure tuple values for clean, readable async code.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var ct = cancellationToken;
/// var response = await GetUserDataAsync(userId)
///     .MatchAsync(
///         onSuccess: (email, name) => CreateUserAsync(email, name, ct),
///         onFailure: error => LogErrorAsync(error, ct)
///     );
/// </code>
/// </example>
[DebuggerStepThrough]
public static class MatchTupleExtensionsAsync
{
<# for (int tupleSize = MinTupleSize; tupleSize <= MaxTupleSize; tupleSize++) { 
    string typeParams = GetTypeParams(tupleSize);
    string tupleType = GetTupleType(tupleSize);
    string valueParams = GetValueParams(tupleSize);
    string funcParams = GetFuncParams(tupleSize);
#>
    /// <summary>
    /// Asynchronously matches on a Result containing a <#= tupleSize #>-element tuple with synchronous handlers, destructuring the tuple values.
    /// </summary>
<# for (int i = 1; i <= tupleSize; i++) { #>
    /// <typeparam name="T<#= i #>">The type of the <#= GetOrdinal(i) #> tuple element.</typeparam>
<# } #>
    /// <typeparam name="TOut">The type of the output.</typeparam>
    /// <param name="resultTask">The task representing the result to match on.</param>
    /// <param name="onSuccess">Function to execute on success, receiving <#= tupleSize #> destructured tuple values.</param>
    /// <param name="onFailure">Function to execute on failure.</param>
    /// <returns>A task that represents the asynchronous operation containing the output from either function.</returns>
    public static async Task<TOut> MatchAsync<<#= typeParams #>, TOut>(
        this Task<Result<<#= tupleType #>>> resultTask,
        Func<<#= funcParams #>, TOut> onSuccess,
        Func<Error, TOut> onFailure)
    {
        var result = await resultTask.ConfigureAwait(false);
        return result.Match(onSuccess, onFailure);
    }

<# } #>
<# for (int tupleSize = MinTupleSize; tupleSize <= MaxTupleSize; tupleSize++) { 
    string typeParams = GetTypeParams(tupleSize);
    string tupleType = GetTupleType(tupleSize);
    string valueParams = GetValueParams(tupleSize);
    string funcParams = GetFuncParams(tupleSize);
    string destructure = GetDestructure(tupleSize);
#>
    /// <summary>
    /// Matches on a Result containing a <#= tupleSize #>-element tuple with asynchronous handlers, destructuring the tuple values.
    /// </summary>
<# for (int i = 1; i <= tupleSize; i++) { #>
    /// <typeparam name="T<#= i #>">The type of the <#= GetOrdinal(i) #> tuple element.</typeparam>
<# } #>
    /// <typeparam name="TOut">The type of the output.</typeparam>
    /// <param name="result">The result to match on.</param>
    /// <param name="onSuccess">Async function to execute on success, receiving <#= tupleSize #> destructured tuple values.</param>
    /// <param name="onFailure">Async function to execute on failure.</param>
    /// <returns>A task that represents the asynchronous operation containing the output from either function.</returns>
    public static async Task<TOut> MatchAsync<<#= typeParams #>, TOut>(
        this Result<<#= tupleType #>> result,
        Func<<#= funcParams #>, Task<TOut>> onSuccess,
        Func<Error, Task<TOut>> onFailure)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        if (result.IsSuccess)
        {
            activity?.SetStatus(ActivityStatusCode.Ok);
            <#= destructure #>
            return await onSuccess(<#= valueParams #>).ConfigureAwait(false);
        }
        else
        {
            activity?.SetStatus(ActivityStatusCode.Error);
            return await onFailure(result.Error).ConfigureAwait(false);
        }
    }

<# } #>
<# for (int tupleSize = MinTupleSize; tupleSize <= MaxTupleSize; tupleSize++) { 
    string typeParams = GetTypeParams(tupleSize);
    string tupleType = GetTupleType(tupleSize);
    string funcParams = GetFuncParams(tupleSize);
#>
    /// <summary>
    /// Asynchronously matches on a Result containing a <#= tupleSize #>-element tuple with async handlers, destructuring the tuple values.
    /// </summary>
<# for (int i = 1; i <= tupleSize; i++) { #>
    /// <typeparam name="T<#= i #>">The type of the <#= GetOrdinal(i) #> tuple element.</typeparam>
<# } #>
    /// <typeparam name="TOut">The type of the output.</typeparam>
    /// <param name="resultTask">The task representing the result to match on.</param>
    /// <param name="onSuccess">Async function to execute on success, receiving <#= tupleSize #> destructured tuple values.</param>
    /// <param name="onFailure">Async function to execute on failure.</param>
    /// <returns>A task that represents the asynchronous operation containing the output from either function.</returns>
    public static async Task<TOut> MatchAsync<<#= typeParams #>, TOut>(
        this Task<Result<<#= tupleType #>>> resultTask,
        Func<<#= funcParams #>, Task<TOut>> onSuccess,
        Func<Error, Task<TOut>> onFailure)
    {
        var result = await resultTask.ConfigureAwait(false);
        return await result.MatchAsync(onSuccess, onFailure).ConfigureAwait(false);
    }

<# } #>
<# for (int tupleSize = MinTupleSize; tupleSize <= MaxTupleSize; tupleSize++) { 
    string typeParams = GetTypeParams(tupleSize);
    string tupleType = GetTupleType(tupleSize);
    string valueParams = GetValueParams(tupleSize);
    string funcParams = GetFuncParams(tupleSize);
    string destructure = GetDestructure(tupleSize);
#>
    /// <summary>
    /// Asynchronously switches on a Result containing a <#= tupleSize #>-element tuple for side effects, destructuring the tuple values.
    /// </summary>
<# for (int i = 1; i <= tupleSize; i++) { #>
    /// <typeparam name="T<#= i #>">The type of the <#= GetOrdinal(i) #> tuple element.</typeparam>
<# } #>
    /// <param name="resultTask">The task representing the result to switch on.</param>
    /// <param name="onSuccess">Async action to execute on success, receiving <#= tupleSize #> destructured tuple values.</param>
    /// <param name="onFailure">Async action to execute on failure, receiving the error.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    /// <remarks>
    /// Use SwitchAsync for side effects (logging, notifications) without returning a value.
    /// </remarks>
    public static async Task SwitchAsync<<#= typeParams #>>(
        this Task<Result<<#= tupleType #>>> resultTask,
        Func<<#= funcParams #>, Task> onSuccess,
        Func<Error, Task> onFailure)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        var result = await resultTask.ConfigureAwait(false);
        if (result.IsSuccess)
        {
            activity?.SetStatus(ActivityStatusCode.Ok);
            <#= destructure #>
            await onSuccess(<#= valueParams #>).ConfigureAwait(false);
        }
        else
        {
            activity?.SetStatus(ActivityStatusCode.Error);
            await onFailure(result.Error).ConfigureAwait(false);
        }
    }

<# } #>
}
<#+
    string GetOrdinal(int number)
    {
        string[] ordinals = { "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth" };
        return number <= ordinals.Length ? ordinals[number - 1] : $"{number}th";
    }
#>
