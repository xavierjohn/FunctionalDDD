<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="CommonFunction.t4" #>

// <auto-generated>
//   This code was generated by a T4 template (BindTs.g.tt).
//   Any changes made manually to this file will be lost when the template is regenerated.
// </auto-generated>

namespace FunctionalDdd;

/// <summary>
/// Provides Bind extension methods for Result types containing tuples (2-9 elements).
/// These methods enable chaining operations that return Result on tuple values from combined results.
/// </summary>
/// <remarks>
/// These overloads are generated for Result&lt;(T1, T2, ...)&gt; to support tuple-based operations
/// after using Combine to validate multiple inputs together.
/// </remarks>
public static partial class BindExtensions
{

<#
  void WriteArgs(int n) {
     Write(String.Join(", ", Enumerable.Range(1, n).Select(i => "args" + i)));
  }

  for(var i = 2; i <=9; i++) { 
#>
    /// <summary>
    /// Chains an operation that returns a Result based on a <#= i #>-element tuple value.
    /// If the current result is a failure, returns the failure without calling the function.
    /// </summary>
    /// <typeparam name="TResult">The type of the result value returned by the function.</typeparam>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The function to execute on the tuple elements if the result is successful.</param>
    /// <returns>A new Result containing the function's result, or the original failure.</returns>
    /// <example>
    /// <code>
    /// var result = FirstName.TryCreate("John")
    ///     .Combine(LastName.TryCreate("Doe"))
<# if(i > 2) { #>
<#   for(var k = 3; k <= i; k++) { #>
    ///     .Combine(Field<#= k #>.TryCreate("value<#= k #>"))
<#   } #>
<# } #>
    ///     .Bind((<# for(var j = 1; j <= i; j++) { #><#= j > 1 ? ", " : "" #>arg<#= j #><# } #>) => CreateEntity(<# for(var j = 1; j <= i; j++) { #><#= j > 1 ? ", " : "" #>arg<#= j #><# } #>));
    /// </code>
    /// </example>
    public static Result<TResult> Bind<<# WriteTs(i); #>, TResult>(
        this Result<(<# WriteTs(i); #>)> result,
        Func<<# WriteTs(i); #>, Result<TResult>> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity();
        if (result.IsFailure)
            return Result.Failure<TResult>(result.Error);

        var (<# WriteArgs(i); #>) = result.Value;
        return func(<# WriteArgs(i); #>);
    }

<#
 }
#>
}

/// <summary>
/// Provides asynchronous Bind extension methods for Result types containing tuples (2-9 elements).
/// Supports both Task and ValueTask for async operations.
/// </summary>
/// <remarks>
/// <para>
/// These methods handle various async scenarios.
/// Users should capture CancellationToken in their lambda closures when cancellation support is needed.
/// </para>
/// <para>
/// Both Task and ValueTask variants are provided for performance optimization scenarios.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var ct = cancellationToken;
/// var result = await emailResult
///     .Combine(userIdResult)
///     .BindAsync((email, userId) => CreateUserAsync(email, userId, ct));
/// </code>
/// </example>
public static partial class BindExtensionsAsync
{
<# 
  for(var i = 2; i <= 9; i++) { 
#>
    // ==================== <#= i #>-Tuple Methods ====================

    /// <summary>
    /// Asynchronously chains an operation on a <#= i #>-element tuple result.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <typeparam name="TResult">The type of the result value.</typeparam>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async function to execute on the tuple elements.</param>
    /// <returns>A task that represents the asynchronous operation containing the new result.</returns>
    public static async Task<Result<TResult>> BindAsync<<# WriteTs(i); #>, TResult>(
        this Result<(<# WriteTs(i); #>)> result,
        Func<<# WriteTs(i); #>, Task<Result<TResult>>> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity(nameof(BindExtensions.Bind));
        if (result.IsFailure)
            return Result.Failure<TResult>(result.Error);

        var (<# WriteArgs(i); #>) = result.Value;
        return await func(<# WriteArgs(i); #>).ConfigureAwait(false);
    }

    /// <summary>
    /// Asynchronously chains an operation on a <#= i #>-element tuple result (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <typeparam name="TResult">The type of the result value.</typeparam>
    /// <param name="result">The result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async function to execute on the tuple elements.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the new result.</returns>
    public static async ValueTask<Result<TResult>> BindAsync<<# WriteTs(i); #>, TResult>(
        this Result<(<# WriteTs(i); #>)> result,
        Func<<# WriteTs(i); #>, ValueTask<Result<TResult>>> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity(nameof(BindExtensions.Bind));
        if (result.IsFailure)
            return Result.Failure<TResult>(result.Error);

        var (<# WriteArgs(i); #>) = result.Value;
        return await func(<# WriteArgs(i); #>).ConfigureAwait(false);
    }

    /// <summary>
    /// Chains a synchronous operation on an asynchronous <#= i #>-element tuple result.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <typeparam name="TResult">The type of the result value.</typeparam>
    /// <param name="resultTask">The task representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The synchronous function to execute on the tuple elements.</param>
    /// <returns>A task that represents the asynchronous operation containing the new result.</returns>
    public static async Task<Result<TResult>> BindAsync<<# WriteTs(i); #>, TResult>(
        this Task<Result<(<# WriteTs(i); #>)>> resultTask,
        Func<<# WriteTs(i); #>, Result<TResult>> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity(nameof(BindExtensions.Bind));
        var result = await resultTask.ConfigureAwait(false);
        if (result.IsFailure)
            return Result.Failure<TResult>(result.Error);

        var (<# WriteArgs(i); #>) = result.Value;
        return func(<# WriteArgs(i); #>);
    }

    /// <summary>
    /// Chains a synchronous operation on an asynchronous <#= i #>-element tuple result (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <typeparam name="TResult">The type of the result value.</typeparam>
    /// <param name="resultTask">The ValueTask representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The synchronous function to execute on the tuple elements.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the new result.</returns>
    public static async ValueTask<Result<TResult>> BindAsync<<# WriteTs(i); #>, TResult>(
        this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
        Func<<# WriteTs(i); #>, Result<TResult>> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity(nameof(BindExtensions.Bind));
        var result = await resultTask.ConfigureAwait(false);
        if (result.IsFailure)
            return Result.Failure<TResult>(result.Error);

        var (<# WriteArgs(i); #>) = result.Value;
        return func(<# WriteArgs(i); #>);
    }

    /// <summary>
    /// Chains an asynchronous operation on an asynchronous <#= i #>-element tuple result.
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <typeparam name="TResult">The type of the result value.</typeparam>
    /// <param name="resultTask">The task representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async function to execute on the tuple elements.</param>
    /// <returns>A task that represents the asynchronous operation containing the new result.</returns>
    public static async Task<Result<TResult>> BindAsync<<# WriteTs(i); #>, TResult>(
        this Task<Result<(<# WriteTs(i); #>)>> resultTask,
        Func<<# WriteTs(i); #>, Task<Result<TResult>>> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity(nameof(BindExtensions.Bind));
        var result = await resultTask.ConfigureAwait(false);
        if (result.IsFailure)
            return Result.Failure<TResult>(result.Error);

        var (<# WriteArgs(i); #>) = result.Value;
        return await func(<# WriteArgs(i); #>).ConfigureAwait(false);
    }

    /// <summary>
    /// Chains an asynchronous operation on an asynchronous <#= i #>-element tuple result (ValueTask variant).
    /// </summary>
<# for(var j = 1; j <= i; j++) { #>
    /// <typeparam name="T<#= j #>">The type of element <#= j #> in the tuple.</typeparam>
<# } #>
    /// <typeparam name="TResult">The type of the result value.</typeparam>
    /// <param name="resultTask">The ValueTask representing the result containing a <#= i #>-element tuple.</param>
    /// <param name="func">The async function to execute on the tuple elements.</param>
    /// <returns>A ValueTask that represents the asynchronous operation containing the new result.</returns>
    public static async ValueTask<Result<TResult>> BindAsync<<# WriteTs(i); #>, TResult>(
        this ValueTask<Result<(<# WriteTs(i); #>)>> resultTask,
        Func<<# WriteTs(i); #>, ValueTask<Result<TResult>>> func)
    {
        using var activity = RopTrace.ActivitySource.StartActivity(nameof(BindExtensions.Bind));
        var result = await resultTask.ConfigureAwait(false);
        if (result.IsFailure)
            return Result.Failure<TResult>(result.Error);

        var (<# WriteArgs(i); #>) = result.Value;
        return await func(<# WriteArgs(i); #>).ConfigureAwait(false);
    }

<#
 }
#>
}
