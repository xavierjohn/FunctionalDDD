namespace RailwayOrientedProgramming.Tests.Results.Extensions;

using System.Diagnostics;
using FunctionalDdd.Testing;
using RailwayOrientedProgramming.Tests.Helpers;

/// <summary>
/// Tests for Activity tracing in Tap operations on tuple results generated by TapTs.g.tt.
/// Verifies that Tap methods create proper OpenTelemetry activities with correct status codes.
/// 
/// Since tuple-based Tap methods are generated from the same T4 template pattern, we test the 2-tuple
/// permutation comprehensively to validate the template logic.
/// </summary>
public class TapTupleTracingTests : TestBase
{
    #region 2-Tuple Tap Tracing Tests

    [Fact]
    public void Tap_2Tuple_Success_CreatesActivityWithOkStatus()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();
        var result = Result.Success((42, "hello"));

        // Act
        var actual = result.Tap((a, b) => { /* side effect */ });

        // Assert
        actual.Should().BeSuccess();
        activityTest.AssertActivityCapturedWithStatus("Tap", ActivityStatusCode.Ok);
    }

    [Fact]
    public void Tap_2Tuple_Failure_CreatesActivityWithErrorStatus()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();
        var result = Result.Failure<(int, string)>(Error.Validation("Validation failed"));

        // Act
        var actual = result.Tap((a, b) => { /* should not execute */ });

        // Assert
        actual.Should().BeFailure();
        activityTest.AssertActivityCapturedWithStatus("Tap", ActivityStatusCode.Error);
    }

    [Fact]
    public void Tap_2Tuple_ChainedActions_CreatesMultipleActivities()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();
        var result = Result.Success((42, "hello"));

        // Act
        var actual = result
            .Tap((a, b) => { /* First tap */ })
            .Tap((a, b) => { /* Second tap */ })
            .Tap((a, b) => { /* Third tap */ });

        // Assert
        actual.Should().BeSuccess();
        activityTest.AssertActivityCaptured(3); // Should have 3 separate activities

        // All activities should have Ok status (verified by individual checks)
        var activities = activityTest.CapturedActivities;
        activities.Should().OnlyContain(a =>
            a.DisplayName == "Tap" && a.Status == ActivityStatusCode.Ok);
    }

    [Fact]
    public void Tap_2Tuple_DifferentTypes_CreatesActivityWithOkStatus()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();
        var result = Result.Success(("text", 123));

        // Act
        var actual = result.Tap((str, num) => { /* Log values */ });

        // Assert
        actual.Should().BeSuccess();
        activityTest.AssertActivityCapturedWithStatus("Tap", ActivityStatusCode.Ok);
    }

    #endregion

    #region Async Tap Tracing Tests

    [Fact]
    public async Task TapAsync_2Tuple_TaskResult_Success_CreatesActivity()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();
        var result = Task.FromResult(Result.Success((42, "hello")));

        // Act
        await result.TapAsync((a, b) => { });

        // Assert
        // Wait for async activity capture
        await Task.Delay(50, TestContext.Current.CancellationToken);
        activityTest.ActivityCount.Should().BeGreaterThan(0);
    }

    [Fact]
    public async Task TapAsync_2Tuple_WithFuncTask_Success_CreatesActivityWithOkStatus()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();
        var result = Result.Success((42, "hello"));

        // Act
        await result.TapAsync((a, b) => Task.CompletedTask);

        // Assert
        // Wait for async activity capture
        await Task.Delay(50, TestContext.Current.CancellationToken);
        activityTest.ActivityCount.Should().BeGreaterThan(0);
    }

    [Fact]
    public async Task TapAsync_2Tuple_WithFuncTask_Failure_CreatesActivityWithErrorStatus()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();
        var result = Result.Failure<(int, string)>(Error.Unexpected("Error"));

        // Act
        await result.TapAsync((a, b) => Task.CompletedTask);

        // Assert
        // Wait for async activity capture
        await Task.Delay(50, TestContext.Current.CancellationToken);
        activityTest.ActivityCount.Should().BeGreaterThan(0);
    }

    [Fact]
    public async Task TapAsync_2Tuple_WithFuncValueTask_Success_CreatesActivity()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();
        var result = Result.Success((42, "hello"));

        // Act
        await result.TapAsync((a, b) => ValueTask.CompletedTask);

        // Assert
        // Wait for async activity capture
        await Task.Delay(50, TestContext.Current.CancellationToken);
        activityTest.ActivityCount.Should().BeGreaterThan(0);
    }

    #endregion

    #region Other Tuple Sizes Validation

    [Fact]
    public void Tap_3Tuple_Success_CreatesActivityWithOkStatus()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();
        var result = Result.Success((1, "two", true));

        // Act
        result.Tap((a, b, c) => { });

        // Assert
        activityTest.AssertActivityCapturedWithStatus("Tap", ActivityStatusCode.Ok);
    }

    [Fact]
    public void Tap_4Tuple_Success_CreatesActivityWithOkStatus()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();
        var result = Result.Success((1, 2, 3, 4));

        // Act
        result.Tap((a, b, c, d) => { });

        // Assert
        activityTest.AssertActivityCapturedWithStatus("Tap", ActivityStatusCode.Ok);
    }

    [Fact]
    public void Tap_5Tuple_Success_CreatesActivityWithOkStatus()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();
        var result = Result.Success((1, 2, 3, 4, 5));

        // Act
        result.Tap((a, b, c, d, e) => { });

        // Assert
        activityTest.AssertActivityCapturedWithStatus("Tap", ActivityStatusCode.Ok);
    }

    [Fact]
    public void Tap_9Tuple_Success_CreatesActivityWithOkStatus()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();
        var result = Result.Success((1, 2, 3, 4, 5, 6, 7, 8, 9));

        // Act
        result.Tap((a, b, c, d, e, f, g, h, i) => { });

        // Assert
        activityTest.AssertActivityCapturedWithStatus("Tap", ActivityStatusCode.Ok);
    }

    [Fact]
    public void Tap_9Tuple_Failure_CreatesActivityWithErrorStatus()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();
        var result = Result.Failure<(int, int, int, int, int, int, int, int, int)>(Error.NotFound("Not found"));

        // Act
        result.Tap((a, b, c, d, e, f, g, h, i) => { });

        // Assert
        activityTest.AssertActivityCapturedWithStatus("Tap", ActivityStatusCode.Error);
    }

    #endregion

    #region Integration Scenarios with Tracing

    [Fact]
    public void Tap_AfterCombine_TracesCorrectly()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();

        // Act
        var result = Result.Success("John")
            .Combine(Result.Success("Doe"))
            .Tap((first, last) => { /* Log full name */ });

        // Assert
        result.Should().BeSuccess();

        // Should have 1 Combine + 1 Tap activity
        activityTest.AssertActivityCaptured(2);

        // Verify Tap activity has Ok status
        activityTest.AssertActivityCapturedWithStatus("Tap", ActivityStatusCode.Ok);
    }

    [Fact]
    public void Tap_WithBind_TracesAllOperations()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();

        // Act
        var result = Result.Success("user@example.com")
            .Combine(Result.Success("John"))
            .Tap((email, name) => { /* Log user creation */ })
            .Bind((email, name) => Result.Success($"{name} <{email}>"));

        // Assert
        result.Should().BeSuccess();

        // Should have Combine + Tap + Bind activities
        activityTest.AssertActivityCaptured(3);
        activityTest.AssertActivityCapturedWithStatus("Tap", ActivityStatusCode.Ok);
        activityTest.AssertActivityCapturedWithStatus("Bind", ActivityStatusCode.Ok);
    }

    [Fact]
    public void Tap_MultipleCombined_TracesAllSuccesses()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();

        // Act
        var result = Result.Success("user@example.com")
            .Combine(Result.Success("John"))
            .Combine(Result.Success("Doe"))
            .Tap((email, first, last) => { /* Log complete user */ });

        // Assert
        result.Should().BeSuccess();

        // Should have 2 Combines + 1 Tap
        activityTest.ActivityCount.Should().BeGreaterThan(0);

        // Verify Tap has Ok status
        var activities = activityTest.CapturedActivities;
        activities.Should().Contain(a =>
            a.DisplayName == "Tap" &&
            a.Status == ActivityStatusCode.Ok);
    }

    [Fact]
    public void Tap_ChainedWithMatch_TracesSuccessPath()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();

        // Act
        var result = Result.Success("John")
            .Combine(Result.Success("Doe"))
            .Tap((first, last) => { /* Log before match */ })
            .Match(
                onSuccess: (first, last) => $"{first} {last}",
                onFailure: error => "Error"
            );

        // Assert
        result.Should().Be("John Doe");

        // Should have Combine + Tap + Match activities
        activityTest.AssertActivityCaptured(3);
    }

    [Fact]
    public void Tap_FailureAfterCombine_TapNotExecutedButTraced()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();

        // Act
        var result = Result.Success("valid")
            .Combine(Result.Failure<string>(Error.Validation("Invalid")))
            .Tap((a, b) => { /* Should not execute */ });

        // Assert
        result.Should().BeFailure();

        // Tap should create activity with Error status (not executed)
        activityTest.AssertActivityCapturedWithStatus("Tap", ActivityStatusCode.Error);
    }

    [Fact]
    public async Task TapAsync_ComplexPipeline_TracesAllOperations()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();

        // Act
        var result = await Result.Success("user@example.com")
            .Combine(Result.Success("password123"))
            .TapAsync((email, password) => Task.CompletedTask)
            .BindAsync((email, password) => Task.FromResult(Result.Success($"User_{email}")))
            .TapAsync(userId => Task.CompletedTask);

        // Assert
        result.Should().BeSuccess();

        // Wait for async activities
        await Task.Delay(100, TestContext.Current.CancellationToken);

        // Should have activities for all operations
        activityTest.ActivityCount.Should().BeGreaterThan(0);
    }

    #endregion

    #region Activity Name Verification

    [Fact]
    public void Tap_CreatesActivity_WithCorrectName()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();
        var result = Result.Success((42, "hello"));

        // Act
        result.Tap((a, b) => { });

        // Assert
        var activity = activityTest.AssertActivityCaptured("Tap");
        activity.DisplayName.Should().Be("Tap");
    }

    [Fact]
    public void Tap_MultipleInChain_AllHaveCorrectName()
    {
        // Arrange
        using var activityTest = new ActivityTestHelper();
        var result = Result.Success((42, "hello"));

        // Act
        result
            .Tap((a, b) => { })
            .Tap((a, b) => { })
            .Tap((a, b) => { });

        // Assert
        var activities = activityTest.AssertActivityCaptured("Tap", 3);
        activities.Should().OnlyContain(a => a.DisplayName == "Tap");
    }

    #endregion
}