namespace RailwayOrientedProgramming.Tests;

using FluentAssertions;
using FunctionalDdd.Testing;
using Xunit;

/// <summary>
/// Functional tests for MatchTuple operations generated by MatchTupleTs.g.tt.
/// Tests automatic tuple destructuring for 2-5 element tuples.
/// Since all tuple sizes are generated from the same T4 template pattern,
/// we test one permutation (2-tuple) comprehensively and validate other sizes work.
/// </summary>
public class MatchTupleTests
{
    #region 2-Tuple Match Tests (Comprehensive Coverage)

    [Fact]
    public void Match_WithSuccessTuple2_DestructuresValues()
    {
        // Arrange
        var result = Result.Success((42, "hello"));

        // Act
        var output = result.Match(
            onSuccess: (num, str) => $"{num}-{str}",
            onFailure: err => $"Error: {err.Detail}"
        );

        // Assert
        output.Should().Be("42-hello");
    }

    [Fact]
    public void Match_WithFailureTuple2_CallsOnFailure()
    {
        // Arrange
        var result = Result.Failure<(int, string)>(Error.NotFound("Not found"));

        // Act
        var output = result.Match(
            onSuccess: (num, str) => $"{num}-{str}",
            onFailure: err => $"Error: {err.Detail}"
        );

        // Assert
        output.Should().Be("Error: Not found");
    }

    [Fact]
    public void Match_WithSuccessTuple2_DifferentTypes_DestructuresCorrectly()
    {
        // Arrange
        var result = Result.Success((true, 3.14));

        // Act
        var output = result.Match(
            onSuccess: (flag, pi) => flag ? pi * 2 : pi,
            onFailure: _ => 0.0
        );

        // Assert
        output.Should().Be(6.28);
    }

    [Fact]
    public void Match_WithFailureTuple2_ValidationError_ReturnsErrorDetail()
    {
        // Arrange
        var result = Result.Failure<(int, string)>(Error.Validation("Invalid input", "field1"));

        // Act
        var output = result.Match(
            onSuccess: (num, str) => "Success",
            onFailure: err => err.Detail
        );

        // Assert
        output.Should().Be("Invalid input");
    }

    [Fact]
    public void Match_WithSuccessTuple2_ComplexTransformation()
    {
        // Arrange
        var result = Result.Success(("John", "Doe"));

        // Act
        var output = result.Match(
            onSuccess: (first, last) => new { FirstName = first, LastName = last, FullName = $"{first} {last}" },
            onFailure: _ => new { FirstName = "", LastName = "", FullName = "" }
        );

        // Assert
        output.FirstName.Should().Be("John");
        output.LastName.Should().Be("Doe");
        output.FullName.Should().Be("John Doe");
    }

    #endregion

    #region 2-Tuple Switch Tests

    [Fact]
    public void Switch_WithSuccessTuple2_DestructuresValues()
    {
        // Arrange
        var result = Result.Success((42, "hello"));
        var output = "";

        // Act
        result.Switch(
            onSuccess: (num, str) => output = $"{num}-{str}",
            onFailure: err => output = $"Error: {err.Detail}"
        );

        // Assert
        output.Should().Be("42-hello");
    }

    [Fact]
    public void Switch_WithFailureTuple2_CallsOnFailure()
    {
        // Arrange
        var result = Result.Failure<(int, string)>(Error.NotFound("Not found"));
        var output = "";

        // Act
        result.Switch(
            onSuccess: (num, str) => output = $"{num}-{str}",
            onFailure: err => output = $"Error: {err.Detail}"
        );

        // Assert
        output.Should().Be("Error: Not found");
    }

    [Fact]
    public void Switch_WithSuccessTuple2_SideEffects()
    {
        // Arrange
        var result = Result.Success((5, 10));
        var sum = 0;
        var product = 0;

        // Act
        result.Switch(
            onSuccess: (a, b) =>
            {
                sum = a + b;
                product = a * b;
            },
            onFailure: _ => { }
        );

        // Assert
        sum.Should().Be(15);
        product.Should().Be(50);
    }

    [Fact]
    public void Switch_WithFailureTuple2_ExecutesFailureAction()
    {
        // Arrange
        var result = Result.Failure<(int, int)>(Error.Unexpected("Server error"));
        var errorLogged = false;
        var errorMessage = "";

        // Act
        result.Switch(
            onSuccess: (a, b) => { },
            onFailure: err =>
            {
                errorLogged = true;
                errorMessage = err.Detail;
            }
        );

        // Assert
        errorLogged.Should().BeTrue();
        errorMessage.Should().Be("Server error");
    }

    #endregion

    #region Other Tuple Sizes (Validation Tests)

    #endregion

    #region Other Tuple Sizes (Validation Tests)

    [Fact]
    public void Match_WithSuccessTuple3_DestructuresValues()
    {
        // Arrange
        var result = Result.Success((1, "two", 3.0));

        // Act
        var output = result.Match(
            onSuccess: (i, s, d) => $"{i}-{s}-{d}",
            onFailure: err => $"Error: {err.Detail}"
        );

        // Assert
        output.Should().Be("1-two-3");
    }

    [Fact]
    public void Match_WithFailureTuple3_CallsOnFailure()
    {
        // Arrange
        var result = Result.Failure<(int, string, double)>(Error.Forbidden("Access denied"));

        // Act
        var output = result.Match(
            onSuccess: (i, s, d) => "Success",
            onFailure: err => err.Detail
        );

        // Assert
        output.Should().Be("Access denied");
    }

    [Fact]
    public void Match_WithSuccessTuple4_DestructuresValues()
    {
        // Arrange
        var result = Result.Success((1, 2, 3, 4));

        // Act
        var output = result.Match(
            onSuccess: (a, b, c, d) => a + b + c + d,
            onFailure: err => 0
        );

        // Assert
        output.Should().Be(10);
    }

    [Fact]
    public void Match_WithFailureTuple4_CallsOnFailure()
    {
        // Arrange
        var result = Result.Failure<(int, int, int, int)>(Error.Conflict("Conflict occurred"));

        // Act - Use base Match since tuple destructuring is only for success
        var output = result.Match(
            onSuccess: (a, b, c, d) => a + b + c + d,
            onFailure: err => 0
        );

        // Assert - Should call onFailure, returning 0
        output.Should().Be(0);
    }

    [Fact]
    public void Match_WithSuccessTuple5_DestructuresValues()
    {
        // Arrange
        var result = Result.Success((1, 2, 3, 4, 5));

        // Act
        var output = result.Match(
            onSuccess: (a, b, c, d, e) => a + b + c + d + e,
            onFailure: err => 0
        );

        // Assert
        output.Should().Be(15);
    }

    [Fact]
    public void Match_WithFailureTuple5_CallsOnFailure()
    {
        // Arrange
        var result = Result.Failure<(int, int, int, int, int)>(Error.BadRequest("Bad request"));

        // Act
        var output = result.Match(
            onSuccess: (a, b, c, d, e) => a + b + c + d + e,
            onFailure: err => -1
        );

        // Assert - Should call onFailure, returning -1
        output.Should().Be(-1);
    }

    [Fact]
    public void Switch_WithSuccessTuple3_DestructuresValues()
    {
        // Arrange
        var result = Result.Success((1, "two", 3.0));
        var output = "";

        // Act
        result.Switch(
            onSuccess: (i, s, d) => output = $"{i}-{s}-{d}",
            onFailure: err => output = $"Error: {err.Detail}"
        );

        // Assert
        output.Should().Be("1-two-3");
    }

    [Fact]
    public void Switch_WithFailureTuple3_CallsOnFailure()
    {
        // Arrange
        var result = Result.Failure<(int, string, double)>(Error.RateLimit("Too many requests"));
        var output = "";

        // Act
        result.Switch(
            onSuccess: (i, s, d) => output = "Success",
            onFailure: err => output = err.Detail
        );

        // Assert
        output.Should().Be("Too many requests");
    }

    [Fact]
    public void Switch_WithSuccessTuple4_DestructuresValues()
    {
        // Arrange
        var result = Result.Success((1, 2, 3, 4));
        var sum = 0;

        // Act
        result.Switch(
            onSuccess: (a, b, c, d) => sum = a + b + c + d,
            onFailure: err => sum = 0
        );

        // Assert
        sum.Should().Be(10);
    }

    [Fact]
    public void Switch_WithSuccessTuple5_DestructuresValues()
    {
        // Arrange
        var result = Result.Success((1, 2, 3, 4, 5));
        var sum = 0;

        // Act
        result.Switch(
            onSuccess: (a, b, c, d, e) => sum = a + b + c + d + e,
            onFailure: err => sum = 0
        );

        // Assert
        sum.Should().Be(15);
    }

    #endregion

    #region Async Match Tests

    [Fact]
    public async Task MatchAsync_WithSuccessTuple2_SyncHandlers_DestructuresValues()
    {
        // Arrange
        var resultTask = Task.FromResult(Result.Success((42, "hello")));

        // Act
        var output = await resultTask.MatchAsync(
            onSuccess: (num, str) => $"{num}-{str}",
            onFailure: err => $"Error: {err.Detail}"
        );

        // Assert
        output.Should().Be("42-hello");
    }

    [Fact]
    public async Task MatchAsync_WithFailureTuple2_SyncHandlers_CallsOnFailure()
    {
        // Arrange
        var resultTask = Task.FromResult(Result.Failure<(int, string)>(Error.NotFound("Not found")));

        // Act
        var output = await resultTask.MatchAsync(
            onSuccess: (num, str) => "Success",
            onFailure: err => err.Detail
        );

        // Assert
        output.Should().Be("Not found");
    }

    [Fact]
    public async Task MatchAsync_WithSuccessTuple2_AsyncHandlers_DestructuresValues()
    {
        // Arrange
        var result = Result.Success((42, "hello"));

        // Act
        var output = await result.MatchAsync(
            onSuccess: async (num, str) =>
            {
                await Task.Delay(10);
                return $"{num}-{str}";
            },
            onFailure: async err =>
            {
                await Task.Delay(10);
                return $"Error: {err.Detail}";
            }
        );

        // Assert
        output.Should().Be("42-hello");
    }

    [Fact]
    public async Task MatchAsync_WithFailureTuple2_AsyncHandlers_CallsOnFailure()
    {
        // Arrange
        var result = Result.Failure<(int, string)>(Error.Validation("Invalid", "field"));

        // Act
        var output = await result.MatchAsync(
            onSuccess: async (num, str) =>
            {
                await Task.Delay(10);
                return "Success";
            },
            onFailure: async err =>
            {
                await Task.Delay(10);
                return err.Detail;
            }
        );

        // Assert
        output.Should().Be("Invalid");
    }

    [Fact]
    public async Task MatchAsync_TaskResult_AsyncHandlers_Success()
    {
        // Arrange
        var resultTask = Task.FromResult(Result.Success((10, 20)));

        // Act
        var output = await resultTask.MatchAsync(
            onSuccess: async (a, b) =>
            {
                await Task.Delay(10);
                return a + b;
            },
            onFailure: async err =>
            {
                await Task.Delay(10);
                return 0;
            }
        );

        // Assert
        output.Should().Be(30);
    }

    [Fact]
    public async Task MatchAsync_TaskResult_AsyncHandlers_Failure()
    {
        // Arrange
        var resultTask = Task.FromResult(Result.Failure<(int, int)>(Error.Unexpected("Error")));

        // Act
        var output = await resultTask.MatchAsync(
            onSuccess: async (a, b) =>
            {
                await Task.Delay(10);
                return 100;
            },
            onFailure: async err =>
            {
                await Task.Delay(10);
                return -1;
            }
        );

        // Assert
        output.Should().Be(-1);
    }

    #endregion

    #region Async Switch Tests

    [Fact]
    public async Task SwitchAsync_WithSuccessTuple2_ExecutesSuccessAction()
    {
        // Arrange
        var resultTask = Task.FromResult(Result.Success((42, "hello")));
        var output = "";

        // Act
        await resultTask.SwitchAsync(
            onSuccess: async (num, str) =>
            {
                await Task.Delay(10);
                output = $"{num}-{str}";
            },
            onFailure: async err =>
            {
                await Task.Delay(10);
                output = $"Error: {err.Detail}";
            }
        );

        // Assert
        output.Should().Be("42-hello");
    }

    [Fact]
    public async Task SwitchAsync_WithFailureTuple2_ExecutesFailureAction()
    {
        // Arrange
        var resultTask = Task.FromResult(Result.Failure<(int, string)>(Error.NotFound("Not found")));
        var errorLogged = false;

        // Act
        await resultTask.SwitchAsync(
            onSuccess: async (num, str) => await Task.Delay(10),
            onFailure: async err =>
            {
                await Task.Delay(10);
                errorLogged = true;
            }
        );

        // Assert
        errorLogged.Should().BeTrue();
    }

    [Fact]
    public async Task SwitchAsync_WithSuccessTuple3_DestructuresValues()
    {
        // Arrange
        var resultTask = Task.FromResult(Result.Success((1, 2, 3)));
        var sum = 0;

        // Act
        await resultTask.SwitchAsync(
            onSuccess: async (a, b, c) =>
            {
                await Task.Delay(10);
                sum = a + b + c;
            },
            onFailure: async _ => await Task.CompletedTask
        );

        // Assert
        sum.Should().Be(6);
    }

    #endregion

    #region Real-World Scenarios

    [Fact]
    public void Match_CombinedValidation_ToDto()
    {
        // Arrange
        var emailResult = Result.Success("user@example.com");
        var nameResult = Result.Success("John Doe");
        var combined = emailResult.Combine(nameResult);

        // Act
        var dto = combined.Match(
            onSuccess: (email, name) => new { Email = email, Name = name, IsValid = true },
            onFailure: err => new { Email = "", Name = "", IsValid = false }
        );

        // Assert
        dto.Email.Should().Be("user@example.com");
        dto.Name.Should().Be("John Doe");
        dto.IsValid.Should().BeTrue();
    }

    [Fact]
    public void Match_CombinedValidation_Failure_ToErrorDto()
    {
        // Arrange
        var emailResult = Result.Failure<string>(Error.Validation("Invalid email", "email"));
        var nameResult = Result.Success("John Doe");
        var combined = emailResult.Combine(nameResult);

        // Act
        var response = combined.Match(
            onSuccess: (email, name) => new { Success = true, Error = (string?)null },
            onFailure: err => new { Success = false, Error = (string?)err.Detail }
        );

        // Assert
        response.Success.Should().BeFalse();
        response.Error.Should().Be("Invalid email");
    }

    [Fact]
    public void Switch_CombinedResults_Logging()
    {
        // Arrange
        var result = Result.Success((100, 200, 300));
        var loggedValues = new List<int>();

        // Act
        result.Switch(
            onSuccess: (a, b, c) =>
            {
                loggedValues.Add(a);
                loggedValues.Add(b);
                loggedValues.Add(c);
            },
            onFailure: _ => { }
        );

        // Assert
        loggedValues.Should().ContainInOrder(100, 200, 300);
    }

    #endregion
}