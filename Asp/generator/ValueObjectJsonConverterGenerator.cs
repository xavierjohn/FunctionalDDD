namespace FunctionalDdd.AspSourceGenerator;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

/// <summary>
/// C# source generator that automatically creates AOT-compatible JSON converters
/// and serializer context entries for value objects implementing <c>IScalarValueObject&lt;TSelf, TPrimitive&gt;</c>.
/// </summary>
/// <remarks>
/// <para>
/// This incremental source generator analyzes the codebase for types implementing
/// <c>IScalarValueObject&lt;TSelf, TPrimitive&gt;</c> and generates:
/// <list type="bullet">
/// <item>Strongly-typed JSON converters that don't use runtime reflection</item>
/// <item>A partial class extending any user-defined <c>JsonSerializerContext</c> with <c>[JsonSerializable]</c> attributes</item>
/// <item>Registration code for automatic converter discovery</item>
/// </list>
/// </para>
/// <para>
/// Benefits of using the source generator:
/// <list type="bullet">
/// <item><strong>AOT Compatible</strong>: Generated code works with Native AOT compilation</item>
/// <item><strong>No Reflection</strong>: All type information is resolved at compile time</item>
/// <item><strong>Faster Startup</strong>: No runtime type scanning or assembly reflection</item>
/// <item><strong>Trimming Safe</strong>: Code won't be trimmed away since it's explicitly generated</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// To use the generator, reference it from your project and create a partial JsonSerializerContext:
/// <code>
/// // Mark your context with the [GenerateValueObjectConverters] attribute
/// [GenerateValueObjectConverters]
/// [JsonSerializable(typeof(MyDto))]
/// public partial class AppJsonSerializerContext : JsonSerializerContext
/// {
/// }
///
/// // The generator will automatically add [JsonSerializable] for all value objects:
/// // [JsonSerializable(typeof(CustomerId))]
/// // [JsonSerializable(typeof(FirstName))]
/// // etc.
/// </code>
/// </example>
[Generator(LanguageNames.CSharp)]
public class ValueObjectJsonConverterGenerator : IIncrementalGenerator
{
    private const string GenerateAttributeName = "GenerateValueObjectConvertersAttribute";
    private const string GenerateAttributeFullName = "FunctionalDdd.GenerateValueObjectConvertersAttribute";
    private const string ScalarValueObjectInterfaceName = "IScalarValueObject";

    /// <summary>
    /// Initializes the incremental generator pipeline.
    /// </summary>
    /// <param name="context">The initialization context provided by the compiler.</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the marker attribute
        context.RegisterPostInitializationOutput(static ctx => ctx.AddSource("GenerateValueObjectConvertersAttribute.g.cs", @"// <auto-generated/>
#nullable enable
namespace FunctionalDdd;

using System;

/// <summary>
/// Marks a JsonSerializerContext for automatic generation of [JsonSerializable] attributes
/// for all IScalarValueObject types in the assembly.
/// </summary>
/// <remarks>
/// Apply this attribute to a partial JsonSerializerContext class to have the source generator
/// automatically add [JsonSerializable] attributes for all value object types, enabling
/// AOT-compatible JSON serialization.
/// </remarks>
/// <example>
/// <code>
/// [GenerateValueObjectConverters]
/// [JsonSerializable(typeof(MyDto))]
/// public partial class AppJsonSerializerContext : JsonSerializerContext
/// {
/// }
/// </code>
/// </example>
[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
internal sealed class GenerateValueObjectConvertersAttribute : Attribute
{
}
"));

        // Find all types implementing IScalarValueObject<TSelf, TPrimitive>
        IncrementalValuesProvider<ScalarValueObjectInfo> valueObjectTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (n, _) => IsPotentialValueObject(n),
                transform: static (ctx, ct) => GetValueObjectInfo(ctx, ct))
            .Where(static info => info is not null)!;

        // Find classes with [GenerateValueObjectConverters] attribute
        IncrementalValuesProvider<ClassDeclarationSyntax> contextClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (n, _) => IsJsonSerializerContext(n),
                transform: static (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
            .Where(static c => c is not null);

        // Combine context classes with all value object types
        var combined = contextClasses.Collect().Combine(valueObjectTypes.Collect());

        // Also combine with compilation for namespace resolution
        var withCompilation = context.CompilationProvider.Combine(combined);

        // Generate the output
        context.RegisterSourceOutput(withCompilation,
            static (spc, source) => Execute(source.Left, source.Right.Left, source.Right.Right, spc));
    }

    /// <summary>
    /// Fast syntax-only filter to identify potential value object types.
    /// </summary>
    private static bool IsPotentialValueObject(SyntaxNode node)
    {
        // Look for class declarations with base types that might be value objects
        if (node is ClassDeclarationSyntax c && c.BaseList is not null)
        {
            // Check if any base type contains "ScalarValueObject" or implements IScalarValueObject
            foreach (var baseType in c.BaseList.Types)
            {
                var typeName = baseType.Type.ToString();
                if (typeName.Contains("ScalarValueObject") ||
                    typeName.Contains("RequiredString") ||
                    typeName.Contains("RequiredGuid") ||
                    typeName.Contains(ScalarValueObjectInterfaceName))
                {
                    return true;
                }
            }
        }

        return false;
    }

    /// <summary>
    /// Fast syntax-only filter to identify JsonSerializerContext classes with our attribute.
    /// </summary>
    private static bool IsJsonSerializerContext(SyntaxNode node)
    {
        if (node is ClassDeclarationSyntax c)
        {
            // Check for the [GenerateValueObjectConverters] attribute
            foreach (var attributeList in c.AttributeLists)
            {
                foreach (var attribute in attributeList.Attributes)
                {
                    var name = attribute.Name.ToString();
                    if (name is "GenerateValueObjectConverters" or
                        "GenerateValueObjectConvertersAttribute" or
                        "FunctionalDdd.GenerateValueObjectConverters" or
                        "FunctionalDdd.GenerateValueObjectConvertersAttribute")
                    {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /// <summary>
    /// Extracts value object metadata using semantic analysis.
    /// </summary>
    /// <remarks>
    /// This method looks for base classes (RequiredString, RequiredGuid, ScalarValueObject)
    /// rather than the IScalarValueObject interface because the interface is added by
    /// PrimitiveValueObjectGenerator, and source generators can't see each other's output.
    /// </remarks>
    private static ScalarValueObjectInfo? GetValueObjectInfo(GeneratorSyntaxContext context, CancellationToken ct)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        if (semanticModel.GetDeclaredSymbol(classDeclaration, ct) is not INamedTypeSymbol classSymbol)
            return null;

        // Find the base class and extract primitive type
        var (baseTypeName, primitiveType) = FindValueObjectBaseType(classSymbol);
        if (baseTypeName is null)
            return null;

        // Get primitive type name - either from the ITypeSymbol or from the base type name
        var primitiveTypeName = primitiveType is not null
            ? GetPrimitiveTypeName(primitiveType)
            : GetPrimitiveTypeNameFromBase(baseTypeName);

        return new ScalarValueObjectInfo(
            classSymbol.ContainingNamespace.ToDisplayString(),
            classSymbol.Name,
            primitiveTypeName);
    }

    /// <summary>
    /// Finds the value object base type (RequiredString, RequiredGuid, or ScalarValueObject)
    /// and extracts the primitive type parameter.
    /// </summary>
    private static (string? BaseTypeName, ITypeSymbol? PrimitiveType) FindValueObjectBaseType(INamedTypeSymbol classSymbol)
    {
        var baseType = classSymbol.BaseType;

        while (baseType is not null)
        {
            var baseName = baseType.Name;

            // Check for RequiredString<T> or RequiredGuid<T> (CRTP pattern)
            if (baseName == "RequiredString" && baseType.IsGenericType)
            {
                // The type argument should be the class itself (CRTP), primitive is string
                if (baseType.TypeArguments.Length == 1 &&
                    SymbolEqualityComparer.Default.Equals(baseType.TypeArguments[0], classSymbol))
                {
                    // Return a marker that we'll convert to "string" in GetPrimitiveTypeName
                    return ("RequiredString", null);
                }
            }

            if (baseName == "RequiredGuid" && baseType.IsGenericType)
            {
                // The type argument should be the class itself (CRTP), primitive is Guid
                if (baseType.TypeArguments.Length == 1 &&
                    SymbolEqualityComparer.Default.Equals(baseType.TypeArguments[0], classSymbol))
                {
                    // Return a marker that we'll convert to "Guid" in GetPrimitiveTypeName
                    return ("RequiredGuid", null);
                }
            }

            // Check for ScalarValueObject<TSelf, TPrimitive>
            if (baseName == "ScalarValueObject" && baseType.IsGenericType && baseType.TypeArguments.Length == 2)
            {
                // Verify CRTP pattern: first type arg should be the class itself
                if (SymbolEqualityComparer.Default.Equals(baseType.TypeArguments[0], classSymbol))
                {
                    return ("ScalarValueObject", baseType.TypeArguments[1]);
                }
            }

            baseType = baseType.BaseType;
        }

        return (null, null);
    }

    /// <summary>
    /// Gets the primitive type name based on the base class name.
    /// </summary>
    private static string GetPrimitiveTypeNameFromBase(string baseTypeName) =>
        baseTypeName switch
        {
            "RequiredString" => "string",
            "RequiredGuid" => "System.Guid",
            _ => "object"
        };

    /// <summary>
    /// Gets a friendly name for the primitive type.
    /// </summary>
    private static string GetPrimitiveTypeName(ITypeSymbol type) =>
        type.SpecialType switch
        {
            SpecialType.System_String => "string",
            SpecialType.System_Int32 => "int",
            SpecialType.System_Int64 => "long",
            SpecialType.System_Boolean => "bool",
            SpecialType.System_Double => "double",
            SpecialType.System_Decimal => "decimal",
            SpecialType.System_Single => "float",
            SpecialType.System_Int16 => "short",
            SpecialType.System_Byte => "byte",
            _ => type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                    .Replace("global::", "")
        };

    /// <summary>
    /// Executes the source generation for collected types.
    /// </summary>
    private static void Execute(
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> contextClasses,
        ImmutableArray<ScalarValueObjectInfo> valueObjects,
        SourceProductionContext context)
    {
        if (valueObjects.IsDefaultOrEmpty)
            return;

        // Deduplicate value objects by full type name
        var distinctValueObjects = valueObjects
            .GroupBy(vo => vo.FullTypeName)
            .Select(g => g.First())
            .ToList();

        // Generate AOT-compatible JSON converters
        GenerateJsonConverters(distinctValueObjects, context);

        // Generate partial class extensions for each JsonSerializerContext with our attribute
        foreach (var contextClass in contextClasses)
        {
            var semanticModel = compilation.GetSemanticModel(contextClass.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(contextClass) is INamedTypeSymbol contextSymbol)
            {
                GenerateSerializerContextExtension(contextSymbol, distinctValueObjects, context);
            }
        }
    }

    /// <summary>
    /// Generates AOT-compatible JSON converters for all value object types.
    /// </summary>
    private static void GenerateJsonConverters(
        List<ScalarValueObjectInfo> valueObjects,
        SourceProductionContext context)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("namespace FunctionalDdd.Generated;");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine("using FunctionalDdd;");
        sb.AppendLine();

        foreach (var vo in valueObjects)
        {
            GenerateSingleConverter(sb, vo);
            sb.AppendLine();
        }

        // Generate a factory that can create converters for all known types
        GenerateConverterFactory(sb, valueObjects);

        context.AddSource("ValueObjectJsonConverters.g.cs", sb.ToString());
    }

    /// <summary>
    /// Generates a single JSON converter for a value object type.
    /// </summary>
    private static void GenerateSingleConverter(StringBuilder sb, ScalarValueObjectInfo vo)
    {
        var converterName = $"{vo.TypeName}JsonConverter";
        var fullTypeName = vo.FullTypeName;
        var primitiveType = vo.PrimitiveType;

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// AOT-compatible JSON converter for <see cref=\"{fullTypeName}\"/>.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"internal sealed class {converterName} : JsonConverter<{fullTypeName}>");
        sb.AppendLine("{");

        // Read method
        sb.AppendLine($"    public override {fullTypeName}? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (reader.TokenType == JsonTokenType.Null)");
        sb.AppendLine("            return null;");
        sb.AppendLine();

        // Read the primitive value based on type
        GenerateReadPrimitive(sb, primitiveType);

        sb.AppendLine();
        sb.AppendLine($"        var result = {fullTypeName}.TryCreate(primitiveValue, null);");
        sb.AppendLine();
        sb.AppendLine("        if (result.IsFailure)");
        sb.AppendLine("        {");
        sb.AppendLine("            // Return null on validation failure - the value object's TryCreate handles validation");
        sb.AppendLine("            return null;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return result.Value;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Write method
        sb.AppendLine($"    public override void Write(Utf8JsonWriter writer, {fullTypeName} value, JsonSerializerOptions options)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (value is null)");
        sb.AppendLine("        {");
        sb.AppendLine("            writer.WriteNullValue();");
        sb.AppendLine("            return;");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Write the primitive value based on type
        GenerateWritePrimitive(sb, primitiveType);

        sb.AppendLine("    }");
        sb.AppendLine("}");
    }

    /// <summary>
    /// Generates code to read a primitive value from JSON.
    /// </summary>
    private static void GenerateReadPrimitive(StringBuilder sb, string primitiveType)
    {
        switch (primitiveType)
        {
            case "string":
                sb.AppendLine("        var primitiveValue = reader.GetString();");
                break;
            case "int":
                sb.AppendLine("        var primitiveValue = reader.GetInt32();");
                break;
            case "long":
                sb.AppendLine("        var primitiveValue = reader.GetInt64();");
                break;
            case "bool":
                sb.AppendLine("        var primitiveValue = reader.GetBoolean();");
                break;
            case "double":
                sb.AppendLine("        var primitiveValue = reader.GetDouble();");
                break;
            case "decimal":
                sb.AppendLine("        var primitiveValue = reader.GetDecimal();");
                break;
            case "float":
                sb.AppendLine("        var primitiveValue = reader.GetSingle();");
                break;
            case "short":
                sb.AppendLine("        var primitiveValue = reader.GetInt16();");
                break;
            case "byte":
                sb.AppendLine("        var primitiveValue = reader.GetByte();");
                break;
            case "System.Guid":
            case "Guid":
                sb.AppendLine("        var primitiveValue = reader.GetGuid();");
                break;
            case "System.DateTime":
            case "DateTime":
                sb.AppendLine("        var primitiveValue = reader.GetDateTime();");
                break;
            case "System.DateTimeOffset":
            case "DateTimeOffset":
                sb.AppendLine("        var primitiveValue = reader.GetDateTimeOffset();");
                break;
            default:
                // For unknown types, try to deserialize using the options
                sb.AppendLine($"        var primitiveValue = JsonSerializer.Deserialize<{primitiveType}>(ref reader, options);");
                break;
        }
    }

    /// <summary>
    /// Generates code to write a primitive value to JSON.
    /// </summary>
    private static void GenerateWritePrimitive(StringBuilder sb, string primitiveType)
    {
        switch (primitiveType)
        {
            case "string":
                sb.AppendLine("        writer.WriteStringValue(value.Value);");
                break;
            case "int":
            case "long":
            case "short":
            case "byte":
            case "float":
            case "double":
            case "decimal":
                sb.AppendLine("        writer.WriteNumberValue(value.Value);");
                break;
            case "bool":
                sb.AppendLine("        writer.WriteBooleanValue(value.Value);");
                break;
            case "System.Guid":
            case "Guid":
                sb.AppendLine("        writer.WriteStringValue(value.Value);");
                break;
            case "System.DateTime":
            case "DateTime":
            case "System.DateTimeOffset":
            case "DateTimeOffset":
                sb.AppendLine("        writer.WriteStringValue(value.Value);");
                break;
            default:
                sb.AppendLine($"        JsonSerializer.Serialize(writer, value.Value, options);");
                break;
        }
    }

    /// <summary>
    /// Generates a converter factory that returns converters for all known value object types.
    /// </summary>
    private static void GenerateConverterFactory(StringBuilder sb, List<ScalarValueObjectInfo> valueObjects)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Factory for creating AOT-compatible JSON converters for all generated value object types.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("/// This factory provides converters for value objects without requiring runtime reflection.");
        sb.AppendLine("/// Add this to your JsonSerializerOptions.Converters collection.");
        sb.AppendLine("/// </remarks>");
        sb.AppendLine("public sealed class GeneratedValueObjectConverterFactory : JsonConverterFactory");
        sb.AppendLine("{");
        sb.AppendLine("    private static readonly System.Collections.Generic.Dictionary<Type, JsonConverter> _converters = new()");
        sb.AppendLine("    {");

        foreach (var vo in valueObjects)
        {
            sb.AppendLine($"        {{ typeof({vo.FullTypeName}), new {vo.TypeName}JsonConverter() }},");
        }

        sb.AppendLine("    };");
        sb.AppendLine();
        sb.AppendLine("    /// <inheritdoc />");
        sb.AppendLine("    public override bool CanConvert(Type typeToConvert) => _converters.ContainsKey(typeToConvert);");
        sb.AppendLine();
        sb.AppendLine("    /// <inheritdoc />");
        sb.AppendLine("    public override JsonConverter? CreateConverter(Type typeToConvert, JsonSerializerOptions options)");
        sb.AppendLine("    {");
        sb.AppendLine("        return _converters.TryGetValue(typeToConvert, out var converter) ? converter : null;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
    }

    /// <summary>
    /// Generates a partial class extending the user's JsonSerializerContext with [JsonSerializable] attributes.
    /// </summary>
    private static void GenerateSerializerContextExtension(
        INamedTypeSymbol contextSymbol,
        List<ScalarValueObjectInfo> valueObjects,
        SourceProductionContext context)
    {
        var contextNamespace = contextSymbol.ContainingNamespace.ToDisplayString();
        var contextName = contextSymbol.Name;
        var accessibility = contextSymbol.DeclaredAccessibility.ToString().ToLowerInvariant();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {contextNamespace};");
        sb.AppendLine();
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine();

        // Add [JsonSerializable] attributes for all value object types
        foreach (var vo in valueObjects)
        {
            sb.AppendLine($"[JsonSerializable(typeof({vo.FullTypeName}))]");
        }

        sb.AppendLine($"{accessibility} partial class {contextName}");
        sb.AppendLine("{");
        sb.AppendLine("}");

        context.AddSource($"{contextName}.ValueObjects.g.cs", sb.ToString());
    }
}
