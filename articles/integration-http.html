<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>HTTP Client Integration </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="HTTP Client Integration ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/xavierjohn/FunctionalDDD/blob/main/docs/docfx_project/articles/integration-http.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="..//images/fddd.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="http-client-integration">HTTP Client Integration</h1>

<p><strong>Level:</strong> Beginner | <strong>Time:</strong> 20-30 minutes</p>
<p>Learn how to use HttpClient with Railway-Oriented Programming for functional HTTP communication with automatic error handling.</p>
<h2 id="overview">Overview</h2>
<p>The <code>FunctionalDdd.Http</code> package provides extension methods for <code>HttpResponseMessage</code> that integrate seamlessly with Railway-Oriented Programming patterns. Instead of dealing with exceptions and manual status code checks, you get clean, composable operations that return <code>Result&lt;T&gt;</code>.</p>
<p><strong>What you'll learn:</strong></p>
<ul>
<li>✅ Handle specific HTTP status codes (401, 403, 404, 409) functionally</li>
<li>✅ Handle error ranges (all 4xx or 5xx) with custom factories</li>
<li>✅ Deserialize JSON responses to <code>Result&lt;T&gt;</code> or <code>Result&lt;Maybe&lt;T&gt;&gt;</code></li>
<li>✅ Chain HTTP operations with other ROP operations</li>
<li>✅ Work with CancellationToken for proper cancellation support</li>
</ul>
<h2 id="installation">Installation</h2>
<pre><code class="lang-bash">dotnet add package FunctionalDdd.Http
</code></pre>
<h2 id="quick-start">Quick Start</h2>
<h3 id="basic-json-deserialization">Basic JSON Deserialization</h3>
<pre><code class="lang-csharp">using FunctionalDdd;
using System.Net.Http.Json;

// Define your JSON context for AOT compatibility
[JsonSerializable(typeof(User))]
internal partial class UserJsonContext : JsonSerializerContext { }

public async Task&lt;Result&lt;User&gt;&gt; GetUserAsync(string userId, CancellationToken ct)
{
    return await _httpClient.GetAsync($&quot;api/users/{userId}&quot;, ct)
        .HandleNotFoundAsync(Error.NotFound($&quot;User {userId} not found&quot;))
        .ReadResultFromJsonAsync(UserJsonContext.Default.User, ct);
}
</code></pre>
<h3 id="handle-multiple-status-codes">Handle Multiple Status Codes</h3>
<pre><code class="lang-csharp">public async Task&lt;Result&lt;Order&gt;&gt; CreateOrderAsync(CreateOrderRequest request, CancellationToken ct)
{
    return await _httpClient.PostAsJsonAsync(&quot;api/orders&quot;, request, ct)
        .HandleUnauthorizedAsync(Error.Unauthorized(&quot;Please login to create orders&quot;))
        .HandleForbiddenAsync(Error.Forbidden(&quot;You don't have permission to create orders&quot;))
        .HandleConflictAsync(Error.Conflict(&quot;Order already exists&quot;))
        .ReadResultFromJsonAsync(OrderJsonContext.Default.Order, ct);
}
</code></pre>
<h2 id="status-code-handlers">Status Code Handlers</h2>
<h3 id="specific-status-code-handlers">Specific Status Code Handlers</h3>
<p>The library provides handlers for common HTTP status codes that map to specific error types:</p>
<table>
<thead>
<tr>
<th>Handler</th>
<th>Status Code</th>
<th>Error Type</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>HandleNotFound</code></td>
<td>404</td>
<td><code>NotFoundError</code></td>
<td>Resource doesn't exist</td>
</tr>
<tr>
<td><code>HandleUnauthorized</code></td>
<td>401</td>
<td><code>UnauthorizedError</code></td>
<td>Authentication required</td>
</tr>
<tr>
<td><code>HandleForbidden</code></td>
<td>403</td>
<td><code>ForbiddenError</code></td>
<td>Insufficient permissions</td>
</tr>
<tr>
<td><code>HandleConflict</code></td>
<td>409</td>
<td><code>ConflictError</code></td>
<td>Resource already exists or state conflict</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<pre><code class="lang-csharp">var result = await _httpClient.GetAsync($&quot;api/products/{productId}&quot;, ct)
    .HandleNotFoundAsync(Error.NotFound(&quot;Product&quot;, productId))
    .HandleUnauthorizedAsync(Error.Unauthorized(&quot;Please login&quot;))
    .ReadResultFromJsonAsync(ProductJsonContext.Default.Product, ct);

// Result will be:
// - Success&lt;Product&gt; if status is 200 and JSON deserializes
// - Failure&lt;NotFoundError&gt; if status is 404
// - Failure&lt;UnauthorizedError&gt; if status is 401
// - Success with response if other status codes (passes through)
</code></pre>
<h3 id="range-based-handlers">Range-Based Handlers</h3>
<p>Handle entire ranges of status codes with custom error factories:</p>
<h4 id="handleclienterror-4xx">HandleClientError (4xx)</h4>
<p>Handles all client error responses (400-499):</p>
<pre><code class="lang-csharp">var result = await _httpClient.PostAsJsonAsync(&quot;api/orders&quot;, order, ct)
    .HandleClientErrorAsync(statusCode =&gt; statusCode switch
    {
        HttpStatusCode.BadRequest =&gt; Error.BadRequest(&quot;Invalid order data&quot;),
        HttpStatusCode.NotFound =&gt; Error.NotFound(&quot;Endpoint not found&quot;),
        HttpStatusCode.Conflict =&gt; Error.Conflict(&quot;Order already exists&quot;),
        _ =&gt; Error.Unexpected($&quot;Client error: {statusCode}&quot;)
    })
    .ReadResultFromJsonAsync(OrderJsonContext.Default.Order, ct);
</code></pre>
<h4 id="handleservererror-5xx">HandleServerError (5xx)</h4>
<p>Handles all server error responses (500+):</p>
<pre><code class="lang-csharp">var result = await _httpClient.GetAsync(&quot;api/data&quot;, ct)
    .HandleServerErrorAsync(statusCode =&gt; 
        Error.ServiceUnavailable($&quot;API is experiencing issues: {statusCode}&quot;))
    .ReadResultFromJsonAsync(DataJsonContext.Default.Data, ct);
</code></pre>
<h3 id="ensuresuccess">EnsureSuccess</h3>
<p>Functional alternative to <code>HttpResponseMessage.EnsureSuccessStatusCode()</code> that returns a <code>Result</code> instead of throwing an exception:</p>
<pre><code class="lang-csharp">// Default error for non-success status codes
var result = await _httpClient.DeleteAsync($&quot;api/items/{id}&quot;, ct)
    .EnsureSuccessAsync()
    .TapAsync(response =&gt; _logger.LogInformation(&quot;Deleted item {Id}&quot;, id));

// Custom error factory
var result = await _httpClient.PutAsJsonAsync($&quot;api/users/{userId}&quot;, updateData, ct)
    .EnsureSuccessAsync(statusCode =&gt; 
        Error.Unexpected($&quot;Update failed with status {statusCode}&quot;))
    .ReadResultFromJsonAsync(UserJsonContext.Default.User, ct);
</code></pre>
<h2 id="json-deserialization">JSON Deserialization</h2>
<h3 id="readresultfromjsonasync">ReadResultFromJsonAsync</h3>
<p>Deserializes JSON to <code>Result&lt;T&gt;</code>. Returns an error if the response body is null:</p>
<pre><code class="lang-csharp">public async Task&lt;Result&lt;User&gt;&gt; GetUserAsync(string userId, CancellationToken ct)
{
    return await _httpClient.GetAsync($&quot;api/users/{userId}&quot;, ct)
        .ReadResultFromJsonAsync(UserJsonContext.Default.User, ct);
}

// If response is 200 with JSON body → Success&lt;User&gt;
// If response is 200 with null body → Failure&lt;UnexpectedError&gt;
// If response is non-success (4xx, 5xx) → Failure&lt;UnexpectedError&gt;
</code></pre>
<h3 id="readresultmaybefromjsonasync">ReadResultMaybeFromJsonAsync</h3>
<p>Deserializes JSON to <code>Result&lt;Maybe&lt;T&gt;&gt;</code>. Null responses become <code>Maybe.None</code> instead of errors:</p>
<pre><code class="lang-csharp">public async Task&lt;Result&lt;Maybe&lt;Profile&gt;&gt;&gt; GetOptionalProfileAsync(string userId, CancellationToken ct)
{
    return await _httpClient.GetAsync($&quot;api/users/{userId}/profile&quot;, ct)
        .ReadResultMaybeFromJsonAsync(ProfileJsonContext.Default.Profile, ct)
        .TapAsync(maybe =&gt;
        {
            if (maybe.HasValue)
                _logger.LogInformation(&quot;Profile found: {Name}&quot;, maybe.Value.Name);
            else
                _logger.LogInformation(&quot;No profile available&quot;);
        });
}

// If response is 200 with JSON body → Success&lt;Maybe&lt;Profile&gt;&gt; with value
// If response is 200 with null body → Success&lt;Maybe&lt;Profile&gt;&gt; with no value
// If response is non-success (4xx, 5xx) → Failure&lt;UnexpectedError&gt;
</code></pre>
<h2 id="composing-http-calls">Composing HTTP Calls</h2>
<h3 id="chaining-multiple-status-handlers">Chaining Multiple Status Handlers</h3>
<pre><code class="lang-csharp">public async Task&lt;Result&lt;Order&gt;&gt; PlaceOrderAsync(
    CreateOrderRequest request,
    CancellationToken ct)
{
    return await _httpClient.PostAsJsonAsync(&quot;api/orders&quot;, request, ct)
        .HandleUnauthorizedAsync(Error.Unauthorized(&quot;Please login to place orders&quot;))
        .HandleForbiddenAsync(Error.Forbidden(&quot;Your account cannot place orders&quot;))
        .HandleConflictAsync(Error.Conflict(&quot;Order already exists&quot;))
        .HandleClientErrorAsync(code =&gt; Error.BadRequest($&quot;Invalid order data: {code}&quot;))
        .HandleServerErrorAsync(code =&gt; Error.ServiceUnavailable($&quot;Order service unavailable: {code}&quot;))
        .ReadResultFromJsonAsync(OrderJsonContext.Default.Order, ct)
        .TapAsync(order =&gt; _logger.LogInformation(&quot;Order {OrderId} created&quot;, order.Id));
}

// Handlers are evaluated in order - first match wins
// Remaining handlers are skipped once a status code matches
</code></pre>
<h3 id="integration-with-railway-oriented-programming">Integration with Railway-Oriented Programming</h3>
<p>HTTP calls compose naturally with other ROP operations:</p>
<pre><code class="lang-csharp">public async Task&lt;Result&lt;OrderConfirmation&gt;&gt; ProcessOrderWorkflowAsync(
    string orderId,
    CancellationToken ct)
{
    return await _httpClient.GetAsync($&quot;api/orders/{orderId}&quot;, ct)
        .HandleNotFoundAsync(Error.NotFound(&quot;Order&quot;, orderId))
        .HandleUnauthorizedAsync(Error.Unauthorized(&quot;Please login&quot;))
        .ReadResultFromJsonAsync(OrderJsonContext.Default.Order, ct)
        .EnsureAsync(order =&gt; order.Status == &quot;Pending&quot;,
            Error.Validation(&quot;Only pending orders can be processed&quot;))
        .BindAsync((order, token) =&gt; ValidateInventoryAsync(order, token), ct)
        .BindAsync((order, token) =&gt; ProcessPaymentAsync(order, token), ct)
        .TapAsync((order, token) =&gt; SendConfirmationEmailAsync(order, token), ct)
        .MapAsync(order =&gt; new OrderConfirmation(order.Id, order.Total));
}
</code></pre>
<h3 id="parallel-http-calls">Parallel HTTP Calls</h3>
<p>Fetch data from multiple endpoints in parallel:</p>
<pre><code class="lang-csharp">public async Task&lt;Result&lt;Dashboard&gt;&gt; GetDashboardAsync(string userId, CancellationToken ct)
{
    var userTask = _httpClient.GetAsync($&quot;api/users/{userId}&quot;, ct)
        .ReadResultFromJsonAsync(UserJsonContext.Default.User, ct);

    var ordersTask = _httpClient.GetAsync($&quot;api/users/{userId}/orders&quot;, ct)
        .ReadResultFromJsonAsync(OrderListJsonContext.Default.OrderList, ct);

    var preferencesTask = _httpClient.GetAsync($&quot;api/users/{userId}/preferences&quot;, ct)
        .ReadResultMaybeFromJsonAsync(PreferencesJsonContext.Default.Preferences, ct);

    return await userTask
        .ParallelAsync(ordersTask)
        .ParallelAsync(preferencesTask)
        .WhenAllAsync()
        .MapAsync((user, orders, preferencesAsync) =&gt; new Dashboard(
            user,
            orders,
            preferences.GetValueOrDefault(Preferences.Default)));
}
</code></pre>
<h2 id="custom-error-handling">Custom Error Handling</h2>
<h3 id="handlefailureasync">HandleFailureAsync</h3>
<p>For complex error handling scenarios where you need to inspect the response:</p>
<pre><code class="lang-csharp">public async Task&lt;Result&lt;Order&gt;&gt; CreateOrderWithCustomErrorsAsync(
    CreateOrderRequest request,
    CancellationToken ct)
{
    return await _httpClient.PostAsJsonAsync(&quot;api/orders&quot;, request, ct)
        .HandleFailureAsync(
            async (response, context, cancellationToken) =&gt;
            {
                var errorBody = await response.Content.ReadAsStringAsync(cancellationToken);
                var statusCode = response.StatusCode;

                return statusCode switch
                {
                    HttpStatusCode.BadRequest =&gt; Error.Validation($&quot;Invalid order: {errorBody}&quot;),
                    HttpStatusCode.Conflict =&gt; Error.Conflict(&quot;Duplicate order detected&quot;),
                    HttpStatusCode.ServiceUnavailable =&gt; Error.ServiceUnavailable(&quot;Order service is down&quot;),
                    _ =&gt; Error.Unexpected($&quot;Order creation failed ({statusCode}): {errorBody}&quot;)
                };
            },
            context: null,
            ct)
        .ReadResultFromJsonAsync(OrderJsonContext.Default.Order, ct);
}
</code></pre>
<h2 id="best-practices">Best Practices</h2>
<h3 id="1-use-json-source-generators">1. Use JSON Source Generators</h3>
<p>Always use JSON source generators for AOT compatibility and better performance:</p>
<pre><code class="lang-csharp">// Define once per assembly
[JsonSerializable(typeof(User))]
[JsonSerializable(typeof(Order))]
[JsonSerializable(typeof(Product))]
[JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase)]
internal partial class AppJsonContext : JsonSerializerContext { }

// Use everywhere
var user = await _httpClient.GetAsync(&quot;api/users/123&quot;, ct)
    .ReadResultFromJsonAsync(AppJsonContext.Default.User, ct);
</code></pre>
<h3 id="2-handle-expected-errors-explicitly">2. Handle Expected Errors Explicitly</h3>
<p>Use specific handlers for expected error scenarios:</p>
<pre><code class="lang-csharp">// ✅ Good - Explicit handling of expected errors
var result = await _httpClient.GetAsync($&quot;api/users/{userId}&quot;, ct)
    .HandleNotFoundAsync(Error.NotFound(&quot;User not found&quot;))
    .HandleUnauthorizedAsync(Error.Unauthorized(&quot;Please login&quot;))
    .ReadResultFromJsonAsync(UserJsonContext.Default.User, ct);

// ❌ Avoid - Generic catch-all for expected scenarios
var result = await _httpClient.GetAsync($&quot;api/users/{userId}&quot;, ct)
    .EnsureSuccessAsync()  // Too broad
    .ReadResultFromJsonAsync(UserJsonContext.Default.User, ct);
</code></pre>
<h3 id="3-always-pass-cancellationtoken">3. Always Pass CancellationToken</h3>
<p>Support graceful cancellation and timeouts:</p>
<pre><code class="lang-csharp">public async Task&lt;Result&lt;Data&gt;&gt; FetchDataAsync(string id, CancellationToken ct)
{
    return await _httpClient.GetAsync($&quot;api/data/{id}&quot;, ct)
        .HandleNotFoundAsync(Error.NotFound(&quot;Data&quot;, id))
        .ReadResultFromJsonAsync(DataJsonContext.Default.Data, ct)
        .TapAsync((data, token) =&gt; CacheDataAsync(data, token), ct);  // Pass through
}
</code></pre>
<h3 id="4-use-range-handlers-for-fallbacks">4. Use Range Handlers for Fallbacks</h3>
<p>Catch unexpected client/server errors after specific handlers:</p>
<pre><code class="lang-csharp">var result = await _httpClient.PostAsJsonAsync(&quot;api/orders&quot;, order, ct)
    .HandleConflictAsync(Error.Conflict(&quot;Order exists&quot;))  // Specific
    .HandleUnauthorizedAsync(Error.Unauthorized(&quot;Login required&quot;))  // Specific
    .HandleClientErrorAsync(code =&gt; Error.BadRequest($&quot;Client error: {code}&quot;))  // Catch-all 4xx
    .HandleServerErrorAsync(code =&gt; Error.ServiceUnavailable($&quot;Server error: {code}&quot;))  // Catch-all 5xx
    .ReadResultFromJsonAsync(OrderJsonContext.Default.Order, ct);
</code></pre>
<h3 id="5-combine-with-retry-policies">5. Combine with Retry Policies</h3>
<p>Use Polly for retry logic (don't reinvent it):</p>
<pre><code class="lang-csharp">using Polly;
using Polly.Extensions.Http;

// Configure HttpClient with Polly
services.AddHttpClient&lt;IOrderService, OrderService&gt;()
    .AddPolicyHandler(GetRetryPolicy());

static IAsyncPolicy&lt;HttpResponseMessage&gt; GetRetryPolicy()
{
    return HttpPolicyExtensions
        .HandleTransientHttpError()
        .WaitAndRetryAsync(3, retryAttempt =&gt; 
            TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
}

// Then use FunctionalDDD for functional error handling
public async Task&lt;Result&lt;Order&gt;&gt; GetOrderAsync(string orderId, CancellationToken ct)
{
    return await _httpClient.GetAsync($&quot;api/orders/{orderId}&quot;, ct)  // Polly handles retries
        .HandleNotFoundAsync(Error.NotFound(&quot;Order&quot;, orderId))  // FunctionalDDD handles errors
        .ReadResultFromJsonAsync(OrderJsonContext.Default.Order, ct);
}
</code></pre>
<h2 id="complete-example">Complete Example</h2>
<p>Here's a complete service that demonstrates all HTTP integration patterns:</p>
<pre><code class="lang-csharp">using FunctionalDdd;
using System.Net.Http.Json;
using System.Text.Json.Serialization;

[JsonSerializable(typeof(User))]
[JsonSerializable(typeof(Order))]
[JsonSerializable(typeof(OrderList))]
[JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase)]
internal partial class ApiJsonContext : JsonSerializerContext { }

public class OrderApiClient
{
    private readonly HttpClient _httpClient;
    private readonly ILogger&lt;OrderApiClient&gt; _logger;

    public OrderApiClient(HttpClient httpClient, ILogger&lt;OrderApiClient&gt; logger)
    {
        _httpClient = httpClient;
        _logger = logger;
    }

    /// &lt;summary&gt;
    /// Get user with specific error handling
    /// &lt;/summary&gt;
    public async Task&lt;Result&lt;User&gt;&gt; GetUserAsync(string userId, CancellationToken ct)
    {
        return await _httpClient.GetAsync($&quot;api/users/{userId}&quot;, ct)
            .HandleNotFoundAsync(Error.NotFound($&quot;User {userId} not found&quot;))
            .HandleUnauthorizedAsync(Error.Unauthorized(&quot;Authentication required&quot;))
            .ReadResultFromJsonAsync(ApiJsonContext.Default.User, ct)
            .TapAsync(user =&gt; _logger.LogInformation(&quot;Retrieved user: {UserId}&quot;, user.Id));
    }

    /// &lt;summary&gt;
    /// Create order with comprehensive error handling
    /// &lt;/summary&gt;
    public async Task&lt;Result&lt;Order&gt;&gt; CreateOrderAsync(CreateOrderRequest request, CancellationToken ct)
    {
        return await _httpClient.PostAsJsonAsync(&quot;api/orders&quot;, request, ApiJsonContext.Default.CreateOrderRequest, ct)
            .HandleUnauthorizedAsync(Error.Unauthorized(&quot;Please login to create orders&quot;))
            .HandleForbiddenAsync(Error.Forbidden(&quot;Your account cannot place orders&quot;))
            .HandleConflictAsync(Error.Conflict(&quot;Order already exists&quot;))
            .HandleClientErrorAsync(code =&gt; Error.BadRequest($&quot;Invalid order data: {code}&quot;))
            .HandleServerErrorAsync(code =&gt; Error.ServiceUnavailable($&quot;Order service unavailable: {code}&quot;))
            .ReadResultFromJsonAsync(ApiJsonContext.Default.Order, ct)
            .TapAsync(order =&gt; _logger.LogInformation(&quot;Order {OrderId} created&quot;, order.Id));
    }

    /// &lt;summary&gt;
    /// Get optional profile using Maybe pattern
    /// &lt;/summary&gt;
    public async Task&lt;Result&lt;Maybe&lt;UserProfile&gt;&gt;&gt; GetOptionalProfileAsync(string userId, CancellationToken ct)
    {
        return await _httpClient.GetAsync($&quot;api/users/{userId}/profile&quot;, ct)
            .ReadResultMaybeFromJsonAsync(ApiJsonContext.Default.UserProfile, ct)
            .TapAsync(maybe =&gt;
            {
                if (maybe.HasValue)
                    _logger.LogInformation(&quot;Profile found for user {UserId}&quot;, userId);
                else
                    _logger.LogInformation(&quot;No profile for user {UserId}&quot;, userId);
            });
    }

    /// &lt;summary&gt;
    /// Complex workflow with multiple operations
    /// &lt;/summary&gt;
    public async Task&lt;Result&lt;OrderConfirmation&gt;&gt; ProcessOrderWorkflowAsync(
        string orderId,
        CancellationToken ct)
    {
        return await GetOrderAsync(orderId, ct)
            .EnsureAsync(order =&gt; order.Status == &quot;Pending&quot;,
                Error.Validation(&quot;Only pending orders can be processed&quot;))
            .BindAsync((order, token) =&gt; ValidateInventoryAsync(order, token), ct)
            .BindAsync((order, token) =&gt; ProcessPaymentAsync(order, token), ct)
            .TapAsync((order, token) =&gt; SendConfirmationEmailAsync(order, token), ct)
            .MapAsync(order =&gt; new OrderConfirmation(order.Id, order.Total));
    }

    private async Task&lt;Result&lt;Order&gt;&gt; GetOrderAsync(string orderId, CancellationToken ct)
    {
        return await _httpClient.GetAsync($&quot;api/orders/{orderId}&quot;, ct)
            .HandleNotFoundAsync(Error.NotFound(&quot;Order&quot;, orderId))
            .ReadResultFromJsonAsync(ApiJsonContext.Default.Order, ct);
    }

    private async Task&lt;Result&lt;Order&gt;&gt; ValidateInventoryAsync(Order order, CancellationToken ct)
    {
        return await _httpClient.PostAsJsonAsync($&quot;api/orders/{order.Id}/validate-inventory&quot;, order, ct)
            .HandleConflictAsync(Error.Conflict(&quot;Insufficient inventory&quot;))
            .ReadResultFromJsonAsync(ApiJsonContext.Default.Order, ct);
    }

    private async Task&lt;Result&lt;Order&gt;&gt; ProcessPaymentAsync(Order order, CancellationToken ct)
    {
        return await _httpClient.PostAsJsonAsync($&quot;api/orders/{order.Id}/process-payment&quot;, order, ct)
            .HandleClientErrorAsync(code =&gt; Error.BadRequest(&quot;Payment failed&quot;))
            .ReadResultFromJsonAsync(ApiJsonContext.Default.Order, ct);
    }

    private async Task SendConfirmationEmailAsync(Order order, CancellationToken ct)
    {
        await _httpClient.PostAsync($&quot;api/notifications/order-confirmation/{order.Id}&quot;, null, ct);
    }
}
</code></pre>
<h2 id="comparison-with-traditional-approach">Comparison with Traditional Approach</h2>
<h3 id="before-traditional-exception-based">Before (Traditional Exception-Based)</h3>
<pre><code class="lang-csharp">public async Task&lt;User&gt; GetUserAsync(string userId, CancellationToken ct)
{
    try
    {
        var response = await _httpClient.GetAsync($&quot;api/users/{userId}&quot;, ct);
        
        if (response.StatusCode == HttpStatusCode.NotFound)
            throw new NotFoundException($&quot;User {userId} not found&quot;);
            
        if (response.StatusCode == HttpStatusCode.Unauthorized)
            throw new UnauthorizedException(&quot;Please login&quot;);
            
        response.EnsureSuccessStatusCode();  // Throws for other errors
        
        var user = await response.Content.ReadFromJsonAsync&lt;User&gt;(ct);
        
        if (user == null)
            throw new InvalidOperationException(&quot;Response was null&quot;);
            
        _logger.LogInformation(&quot;Retrieved user: {UserId}&quot;, user.Id);
        return user;
    }
    catch (HttpRequestException ex)
    {
        _logger.LogError(ex, &quot;HTTP request failed&quot;);
        throw;
    }
    catch (JsonException ex)
    {
        _logger.LogError(ex, &quot;JSON deserialization failed&quot;);
        throw;
    }
}
</code></pre>
<h3 id="after-functional-with-result">After (Functional with Result)</h3>
<pre><code class="lang-csharp">public async Task&lt;Result&lt;User&gt;&gt; GetUserAsync(string userId, CancellationToken ct)
{
    return await _httpClient.GetAsync($&quot;api/users/{userId}&quot;, ct)
        .HandleNotFoundAsync(Error.NotFound($&quot;User {userId} not found&quot;))
        .HandleUnauthorizedAsync(Error.Unauthorized(&quot;Please login&quot;))
        .ReadResultFromJsonAsync(UserJsonContext.Default.User, ct)
        .TapAsync(user =&gt; _logger.LogInformation(&quot;Retrieved user: {UserId}&quot;, user.Id));
}
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>✅ <strong>No exceptions</strong> - All errors are values in the type system</li>
<li>✅ <strong>Composable</strong> - Chain with other ROP operations</li>
<li>✅ <strong>Explicit</strong> - Return type shows this can fail</li>
<li>✅ <strong>Concise</strong> - 60% less code</li>
<li>✅ <strong>Type-safe</strong> - Compiler enforces error handling</li>
</ul>
<h2 id="next-steps">Next Steps</h2>
<ol>
<li><strong>Explore</strong> <a href="integration-aspnet.html">ASP.NET Core Integration</a> to convert Result back to HTTP responses</li>
<li><strong>Learn</strong> <a href="error-handling.html">Error Handling</a> for working with different error types</li>
<li><strong>Master</strong> <a href="basics.html#working-with-async-operations">Working with Async Operations</a> for proper cancellation support</li>
<li><strong>See</strong> <a href="examples.html">Examples</a> for more real-world patterns</li>
</ol>
<h2 id="api-reference">API Reference</h2>
<p>For complete API documentation, see:</p>
<ul>
<li><a href="https://www.nuget.org/packages/FunctionalDdd.Http">Package README</a></li>
<li>Browse the API reference in the documentation site</li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/xavierjohn/FunctionalDDD/blob/main/docs/docfx_project/articles/integration-http.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
