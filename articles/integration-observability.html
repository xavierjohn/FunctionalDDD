<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Observability &amp; Monitoring </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Observability &amp; Monitoring ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/xavierjohn/FunctionalDDD/blob/main/docs/docfx_project/articles/integration-observability.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="..//images/fddd.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="observability--monitoring">Observability &amp; Monitoring</h1>

<p><strong>Level:</strong> Advanced üöÄ | <strong>Time:</strong> 20-30 min | <strong>Prerequisites:</strong> <a href="basics.html">Basics</a></p>
<p>Enable distributed tracing and monitoring for Railway-Oriented Programming operations with OpenTelemetry and standard Problem Details error responses.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#opentelemetry-tracing">OpenTelemetry Tracing</a></li>
</ul>
<h2 id="opentelemetry-tracing">OpenTelemetry Tracing</h2>
<p>Enable distributed tracing for Railway Oriented Programming operations and Value Objects.</p>
<blockquote>
<p><strong>Important:</strong> Auto-instrumentation (<code>AddRailwayOrientedProgrammingInstrumentation()</code>) traces <strong>every</strong> <code>Result&lt;T&gt;</code> operation and can create significant noise in production. It's recommended to <strong>manually instrument</strong> critical paths and use auto-instrumentation only for development/debugging.</p>
</blockquote>
<h3 id="installation">Installation</h3>
<pre><code class="lang-bash">dotnet add package OpenTelemetry
dotnet add package OpenTelemetry.Exporter.OpenTelemetryProtocol
dotnet add package OpenTelemetry.Extensions.Hosting
</code></pre>
<h3 id="recommended-manual-instrumentation">Recommended: Manual Instrumentation</h3>
<p>For production, manually instrument critical business operations:</p>
<pre><code class="lang-csharp">using System.Diagnostics;

public class OrderService
{
    private static readonly ActivitySource ActivitySource = new(&quot;MyApp.OrderService&quot;);

    public async Task&lt;Result&lt;Order&gt;&gt; ProcessOrderAsync(
        CreateOrderCommand command,
        CancellationToken ct)
    {
        using var activity = ActivitySource.StartActivity(&quot;ProcessOrder&quot;);
        activity?.SetTag(&quot;order.customerId&quot;, command.CustomerId);
        activity?.SetTag(&quot;order.itemCount&quot;, command.Items.Count);

        var result = await _validator.ValidateToResultAsync(command, ct)
            .BindAsync((cmd, cancellationToken) =&gt; 
                CreateOrderAsync(cmd, cancellationToken), ct)
            .TapAsync(async (order, cancellationToken) =&gt; 
                await _repository.SaveAsync(order, cancellationToken), ct);

        // Record result in trace
        activity?.SetTag(&quot;result.isSuccess&quot;, result.IsSuccess);
        if (result.IsFailure)
        {
            activity?.SetTag(&quot;result.error.type&quot;, result.Error.GetType().Name);
            activity?.SetTag(&quot;result.error.detail&quot;, result.Error.Detail);
            activity?.SetStatus(ActivityStatusCode.Error, result.Error.Detail);
        }

        return result;
    }
}

// Register your ActivitySource
builder.Services.AddOpenTelemetry()
    .WithTracing(tracerBuilder =&gt;
    {
        tracerBuilder
            .AddSource(&quot;MyApp.OrderService&quot;)  // Only trace what you register
            .AddAspNetCoreInstrumentation()
            .AddHttpClientInstrumentation()
            .AddOtlpExporter();
    });
</code></pre>
<p><strong>Benefits of manual instrumentation:</strong></p>
<ul>
<li>‚úÖ <strong>Control</strong> - Trace only critical paths</li>
<li>‚úÖ <strong>Performance</strong> - Minimal overhead</li>
<li>‚úÖ <strong>Signal-to-noise</strong> - Clear, actionable traces</li>
<li>‚úÖ <strong>Business context</strong> - Add domain-specific tags</li>
</ul>
<h3 id="auto-instrumentation-developmentdebugging-only">Auto-Instrumentation (Development/Debugging Only)</h3>
<p>Auto-instrumentation is useful for <strong>development and debugging</strong> to see all ROP operations:</p>
<pre><code class="lang-csharp">// ‚ö†Ô∏è Development/debugging only - creates significant trace noise
builder.Services.AddOpenTelemetry()
    .WithTracing(tracerProviderBuilder =&gt;
    {
        tracerProviderBuilder
            .AddRailwayOrientedProgrammingInstrumentation()      // ‚ö†Ô∏è Traces EVERY Result&lt;T&gt; operation
            .AddPrimitiveValueObjectInstrumentation()      // ‚ö†Ô∏è Traces EVERY value object creation
            .AddConsoleExporter();  // Console output for debugging
    });
</code></pre>
<p><strong>Use auto-instrumentation when:</strong></p>
<ul>
<li>üîç Debugging complex ROP chains</li>
<li>üß™ Development/testing environments</li>
<li>üìä Analyzing performance bottlenecks</li>
<li>üêõ Troubleshooting specific issues</li>
</ul>
<p><strong>Avoid in production when:</strong></p>
<ul>
<li>‚ùå High-traffic applications (performance overhead)</li>
<li>‚ùå Cost-sensitive environments (trace volume = $$$)</li>
<li>‚ùå Noise-sensitive monitoring (hard to find signal)</li>
</ul>
<h3 id="production-configuration">Production Configuration</h3>
<p>For production, use <strong>selective instrumentation</strong> with sampling:</p>
<pre><code class="lang-csharp">builder.Services.AddOpenTelemetry()
    .ConfigureResource(resource =&gt; resource
        .AddService(
            serviceName: builder.Configuration[&quot;OpenTelemetry:ServiceName&quot;] ?? &quot;MyApp&quot;,
            serviceVersion: Assembly.GetExecutingAssembly().GetName().Version?.ToString()))
    .WithTracing(tracerProviderBuilder =&gt;
    {
        tracerProviderBuilder
            // ‚úÖ Only register your own ActivitySources
            .AddSource(&quot;MyApp.OrderService&quot;)
            .AddSource(&quot;MyApp.UserService&quot;)
            .AddSource(&quot;MyApp.PaymentService&quot;)
            
            // ‚úÖ Standard infrastructure instrumentation
            .AddAspNetCoreInstrumentation()
            .AddHttpClientInstrumentation()
            .AddEntityFrameworkCoreInstrumentation()
            
            // ‚úÖ Sample to reduce overhead (10% of traces)
            .SetSampler(new TraceIdRatioBasedSampler(0.1))
            
            .AddOtlpExporter(options =&gt;
            {
                options.Endpoint = new Uri(
                    builder.Configuration[&quot;OpenTelemetry:Endpoint&quot;] 
                    ?? &quot;http://localhost:4317&quot;);
            });
    });
</code></pre>
<p><strong>Configuration (appsettings.json):</strong></p>
<pre><code class="lang-json">{
  &quot;OpenTelemetry&quot;: {
    &quot;ServiceName&quot;: &quot;FunctionalDddApi&quot;,
    &quot;Endpoint&quot;: &quot;https://otel-collector.example.com:4317&quot;
  }
}
</code></pre>
<h3 id="manual-instrumentation-patterns">Manual Instrumentation Patterns</h3>
<h4 id="pattern-1-command-handlers">Pattern 1: Command Handlers</h4>
<pre><code class="lang-csharp">public class CreateUserCommandHandler
{
    private static readonly ActivitySource ActivitySource = new(&quot;MyApp.UserCommands&quot;);

    public async ValueTask&lt;Result&lt;User&gt;&gt; Handle(
        CreateUserCommand command,
        CancellationToken ct)
    {
        using var activity = ActivitySource.StartActivity(&quot;CreateUser&quot;);
        activity?.SetTag(&quot;user.email&quot;, command.Email);
        
        var result = await _validator.ValidateToResultAsync(command, ct)
            .BindAsync((cmd, cancellationToken) =&gt; 
                User.CreateAsync(cmd, cancellationToken), ct)
            .TapAsync(async (user, cancellationToken) =&gt; 
                await _repository.SaveAsync(user, cancellationToken), ct);
        
        RecordResult(activity, result);
        return result;
    }

    private static void RecordResult&lt;T&gt;(Activity? activity, Result&lt;T&gt; result)
    {
        if (activity == null) return;
        
        activity.SetTag(&quot;result.isSuccess&quot;, result.IsSuccess);
        if (result.IsFailure)
        {
            activity.SetTag(&quot;result.error.type&quot;, result.Error.GetType().Name);
            activity.SetTag(&quot;result.error.code&quot;, result.Error.Code);
            activity.SetStatus(ActivityStatusCode.Error, result.Error.Detail);
        }
    }
}
</code></pre>
<h4 id="pattern-2-domain-services">Pattern 2: Domain Services</h4>
<pre><code class="lang-csharp">public class PaymentService
{
    private static readonly ActivitySource ActivitySource = new(&quot;MyApp.Payments&quot;);

    public async Task&lt;Result&lt;Payment&gt;&gt; ProcessPaymentAsync(
        Order order,
        PaymentMethod method,
        CancellationToken ct)
    {
        using var activity = ActivitySource.StartActivity(&quot;ProcessPayment&quot;);
        activity?.SetTag(&quot;payment.orderId&quot;, order.Id);
        activity?.SetTag(&quot;payment.amount&quot;, order.TotalAmount);
        activity?.SetTag(&quot;payment.method&quot;, method.ToString());

        var result = await ValidatePaymentMethod(method)
            .BindAsync(async (m, cancellationToken) =&gt; 
                await _gateway.ChargeAsync(order.TotalAmount, m, cancellationToken), ct)
            .TapAsync(async (payment, cancellationToken) =&gt; 
                await _repository.SaveAsync(payment, cancellationToken), ct);

        RecordResult(activity, result);
        return result;
    }
}
</code></pre>
<h4 id="pattern-3-complex-workflows">Pattern 3: Complex Workflows</h4>
<pre><code class="lang-csharp">public class CheckoutWorkflow
{
    private static readonly ActivitySource ActivitySource = new(&quot;MyApp.Checkout&quot;);

    public async Task&lt;Result&lt;Order&gt;&gt; ExecuteAsync(
        CheckoutCommand command,
        CancellationToken ct)
    {
        using var activity = ActivitySource.StartActivity(&quot;Checkout&quot;);
        activity?.SetTag(&quot;checkout.customerId&quot;, command.CustomerId);

        // Trace each step
        using var validateActivity = ActivitySource.StartActivity(&quot;ValidateCheckout&quot;);
        var validationResult = await ValidateCheckoutAsync(command, ct);
        RecordResult(validateActivity, validationResult);
        
        if (validationResult.IsFailure)
            return validationResult.Error;

        using var inventoryActivity = ActivitySource.StartActivity(&quot;CheckInventory&quot;);
        var inventoryResult = await CheckInventoryAsync(command.Items, ct);
        RecordResult(inventoryActivity, inventoryResult);
        
        if (inventoryResult.IsFailure)
            return inventoryResult.Error;

        using var paymentActivity = ActivitySource.StartActivity(&quot;ProcessPayment&quot;);
        var paymentResult = await ProcessPaymentAsync(command.Payment, ct);
        RecordResult(paymentActivity, paymentResult);

        // Continue workflow...
        return await CreateOrderAsync(command, ct);
    }
}
</code></pre>
<h4 id="pattern-4-parallel-operations-with-built-in-tracing">Pattern 4: Parallel Operations with Built-in Tracing</h4>
<p>The <code>ParallelAsync</code> and <code>WhenAllAsync</code> operations automatically create tracing spans to monitor parallel execution:</p>
<pre><code class="lang-csharp">public class FraudDetectionService
{
    public async Task&lt;Result&lt;FraudCheckResult&gt;&gt; ValidateTransactionAsync(
        Transaction transaction,
        CancellationToken ct)
    {
        // ParallelAsync and WhenAllAsync automatically create &quot;WhenAllAsync&quot; spans
        // with parallel.task_count tags for observability
        return await Result.ParallelAsync(
            () =&gt; CheckBlacklistAsync(transaction.AccountId, ct),
            () =&gt; CheckVelocityLimitsAsync(transaction, ct),
            () =&gt; CheckAmountThresholdAsync(transaction, ct),
            () =&gt; CheckGeolocationAsync(transaction, ct)
        )
        .WhenAllAsync()  // Creates span: &quot;WhenAllAsync&quot; with tag &quot;parallel.task_count: 4&quot;
        .BindAsync((blacklist, velocity, amount, geo, cancellationToken) =&gt; 
            CombineChecksAsync(blacklist, velocity, amount, geo, cancellationToken), ct);
    }
}
</code></pre>
<p><strong>Automatic tracing benefits:</strong></p>
<ul>
<li>‚úÖ <strong>Parallel task count</strong> - <code>parallel.task_count</code> tag shows how many operations ran</li>
<li>‚úÖ <strong>Execution duration</strong> - See how long parallel operations took</li>
<li>‚úÖ <strong>Success/failure status</strong> - <code>ActivityStatusCode.Ok</code> or <code>ActivityStatusCode.Error</code></li>
<li>‚úÖ <strong>Error correlation</strong> - Failed operations show error status in traces</li>
</ul>
<p><strong>Trace example in Jaeger/Application Insights:</strong></p>
<pre><code>FraudDetectionService.ValidateTransaction (200ms)
  ‚îî‚îÄ WhenAllAsync (parallel.task_count: 4) (150ms)
     ‚îú‚îÄ CheckBlacklist (50ms) ‚úì
     ‚îú‚îÄ CheckVelocityLimits (100ms) ‚úì
     ‚îú‚îÄ CheckAmountThreshold (30ms) ‚úì
     ‚îî‚îÄ CheckGeolocation (150ms) ‚úì
  ‚îî‚îÄ Bind: CombineChecks (50ms) ‚úì
</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/xavierjohn/FunctionalDDD/blob/main/docs/docfx_project/articles/integration-observability.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
