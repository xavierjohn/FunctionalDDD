<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Performance </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Performance ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/xavierjohn/FunctionalDDD/blob/main/docs/docfx_project/articles/performance.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="..//images/fddd.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="performance">Performance</h1>

<p>This guide covers performance characteristics, benchmarks, and optimization techniques.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#key-metrics">Key Metrics</a></li>
<li><a href="#benchmark-results">Benchmark Results</a></li>
<li><a href="#real-world-context">Real-World Context</a></li>
<li><a href="#optimization-tips">Optimization Tips</a></li>
<li><a href="#running-your-own-benchmarks">Running Your Own Benchmarks</a></li>
</ul>
<h2 id="overview">Overview</h2>
<p>Benchmarks on <strong>.NET 10</strong> show railway-oriented programming adds only <strong>~11-16 nanoseconds</strong> overhead compared to imperative code—less than <strong>0.002%</strong> of typical I/O operations.</p>
<p><strong>Test Environment:</strong></p>
<ul>
<li><strong>CPU</strong>: Intel Core i7-1185G7 @ 3.00GHz</li>
<li><strong>OS</strong>: Windows 11</li>
<li><strong>.NET</strong>: 10.0.1</li>
</ul>
<h2 id="key-metrics">Key Metrics</h2>
<table>
<thead>
<tr>
<th>Metric</th>
<th>Finding</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Overhead</strong></td>
<td>11-16 nanoseconds (~12-13% vs imperative)</td>
</tr>
<tr>
<td><strong>Memory</strong></td>
<td>Identical allocations to imperative code</td>
</tr>
<tr>
<td><strong>Success Path</strong></td>
<td>Highly optimized, minimal allocations</td>
</tr>
<tr>
<td><strong>Error Path</strong></td>
<td>Efficient with short-circuit optimization</td>
</tr>
<tr>
<td><strong>Combine Operations</strong></td>
<td>7-58 ns for 2-5 results</td>
</tr>
<tr>
<td><strong>Bind Operations</strong></td>
<td>9-63 ns for 1-5 chains</td>
</tr>
<tr>
<td><strong>Map Operations</strong></td>
<td>4.6-44.5 ns for 1-5 transforms</td>
</tr>
</tbody>
</table>
<h2 id="benchmark-results">Benchmark Results</h2>
<h3 id="rop-vs-imperative-style">ROP vs Imperative Style</h3>
<p>Direct comparison of ROP versus traditional if-style code:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ROP Happy Path</strong></td>
<td>147 ns</td>
<td>144 B</td>
</tr>
<tr>
<td><strong>Imperative Happy Path</strong></td>
<td>131 ns</td>
<td>144 B</td>
</tr>
<tr>
<td><strong>ROP Error Path</strong></td>
<td>99 ns</td>
<td>184 B</td>
</tr>
<tr>
<td><strong>Imperative Error Path</strong></td>
<td>88 ns</td>
<td>184 B</td>
</tr>
</tbody>
</table>
<p><strong>Key Takeaways:</strong></p>
<ul>
<li>ROP adds <strong>~16 ns</strong> on success path (12% overhead)</li>
<li>ROP adds <strong>~11 ns</strong> on error path (13% overhead)</li>
<li><strong>Identical memory allocations</strong> between approaches</li>
<li>Error paths are faster due to short-circuit optimization</li>
</ul>
<h3 id="core-operation-benchmarks">Core Operation Benchmarks</h3>
<h4 id="combine-operations">Combine Operations</h4>
<p>Aggregating multiple Result objects:</p>
<table>
<thead>
<tr>
<th>Results Combined</th>
<th>Mean Time</th>
<th>Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>2 results</td>
<td>7 ns</td>
<td>0 B</td>
</tr>
<tr>
<td>3 results</td>
<td>30 ns</td>
<td>0 B</td>
</tr>
<tr>
<td>5 results</td>
<td>58 ns</td>
<td>0 B</td>
</tr>
</tbody>
</table>
<p><strong>Zero allocations</strong> - highly efficient for validation scenarios.</p>
<h4 id="bind-operations">Bind Operations</h4>
<p>Chaining operations that return Results:</p>
<table>
<thead>
<tr>
<th>Chain Length</th>
<th>Mean Time</th>
<th>Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 bind</td>
<td>9 ns</td>
<td>0 B</td>
</tr>
<tr>
<td>3 binds</td>
<td>35 ns</td>
<td>0 B</td>
</tr>
<tr>
<td>5 binds</td>
<td>63 ns</td>
<td>0 B</td>
</tr>
</tbody>
</table>
<p><strong>Linear scaling</strong> with excellent performance characteristics.</p>
<h4 id="map-operations">Map Operations</h4>
<p>Transforming successful values:</p>
<table>
<thead>
<tr>
<th>Transforms</th>
<th>Mean Time</th>
<th>Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 map</td>
<td>4.6 ns</td>
<td>0 B</td>
</tr>
<tr>
<td>3 maps</td>
<td>21 ns</td>
<td>0 B</td>
</tr>
<tr>
<td>5 maps</td>
<td>44.5 ns</td>
<td>0 B</td>
</tr>
</tbody>
</table>
<p><strong>Fastest operation</strong> with zero allocations on success path.</p>
<h4 id="tap-operations">Tap Operations</h4>
<p>Executing side effects:</p>
<table>
<thead>
<tr>
<th>Taps</th>
<th>Mean Time</th>
<th>Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 tap</td>
<td>3 ns</td>
<td>0 B</td>
</tr>
<tr>
<td>3 taps</td>
<td>18 ns</td>
<td>32 B</td>
</tr>
<tr>
<td>5 taps</td>
<td>37.4 ns</td>
<td>64 B</td>
</tr>
</tbody>
</table>
<p><strong>Minimal overhead</strong> for logging and side effects.</p>
<h4 id="ensure-operations">Ensure Operations</h4>
<p>Adding validation checks:</p>
<table>
<thead>
<tr>
<th>Checks</th>
<th>Mean Time</th>
<th>Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 ensure</td>
<td>22.5 ns</td>
<td>152 B</td>
</tr>
<tr>
<td>3 ensures</td>
<td>89 ns</td>
<td>456 B</td>
</tr>
<tr>
<td>5 ensures</td>
<td>175 ns</td>
<td>760 B</td>
</tr>
</tbody>
</table>
<p><strong>Note</strong>: Allocations include error object creation for failed validations.</p>
<h3 id="async-operations">Async Operations</h3>
<p>Async operations have similar performance characteristics with additional Task overhead:</p>
<pre><code class="lang-csharp">// Async overhead is from Task machinery, not ROP
await GetUserAsync(id)           // ~1,000,000 ns (database call)
    .BindAsync(ProcessUserAsync)  // + 50 ns (ROP overhead)
    .TapAsync(LogUserAsync);      // + 20 ns (ROP overhead)
</code></pre>
<p>The ROP overhead is <strong>less than 0.01%</strong> of typical async I/O operations.</p>
<h2 id="real-world-context">Real-World Context</h2>
<p>To put these numbers in perspective:</p>
<pre><code>Database Query:    1,000,000 ns (1 ms)
HTTP Request:     10,000,000 ns (10 ms)
File Read:         5,000,000 ns (5 ms)
ROP Chain (5 ops):        150 ns (0.00015 ms)
                          ↑
                     0.015% of a database query
</code></pre>
<p><strong>The 16ns ROP overhead is 1/62,500th of a single database query!</strong></p>
<h3 id="performance-in-web-applications">Performance in Web Applications</h3>
<p>In a typical ASP.NET Core request:</p>
<pre><code class="lang-csharp">// Typical web request processing
app.MapPost(&quot;/orders&quot;, async (CreateOrderRequest request, CancellationToken ct) =&gt;
{
    return await ValidateRequest(request)              // ~50 ns
        .BindAsync((req, ct) =&gt; CreateOrderAsync(req, ct), ct)  // ~1-5 ms (DB write)
        .TapAsync((order, ct) =&gt; PublishEventAsync(order, ct), ct)  // ~10-50 ms (message queue)
        .MatchAsync(
            onSuccess: order =&gt; Results.Created($&quot;/orders/{order.Id}&quot;, order),
            onFailure: error =&gt; error.ToHttpResult()
        );
});

// Total ROP overhead: ~150 ns
// Total request time: ~15-60 ms
// ROP percentage: 0.0003%
</code></pre>
<h2 id="optimization-tips">Optimization Tips</h2>
<h3 id="1-prefer-struct-based-value-objects">1. Prefer Struct-Based Value Objects</h3>
<pre><code class="lang-csharp">// ✅ Good - Struct, no heap allocation
public readonly struct UserId
{
    private readonly Guid _value;
    public UserId(Guid value) =&gt; _value = value;
}

// ❌ Worse - Class, heap allocation
public class UserId
{
    public Guid Value { get; }
    public UserId(Guid value) =&gt; Value = value;
}
</code></pre>
<h3 id="2-use-valuetask-for-hot-paths">2. Use ValueTask for Hot Paths</h3>
<pre><code class="lang-csharp">// ✅ Good - ValueTask for potentially synchronous completions
public ValueTask&lt;Result&lt;User&gt;&gt; GetUserFromCacheAsync(UserId id)
{
    if (_cache.TryGetValue(id, out var user))
        return ValueTask.FromResult(Result.Success(user));
    
    return new ValueTask&lt;Result&lt;User&gt;&gt;(FetchFromDbAsync(id));
}

// ❌ Allocates Task even when cached
public Task&lt;Result&lt;User&gt;&gt; GetUserFromCacheAsync(UserId id)
{
    if (_cache.TryGetValue(id, out var user))
        return Task.FromResult(Result.Success(user));
    
    return FetchFromDbAsync(id);
}
</code></pre>
<h3 id="3-combine-before-bind">3. Combine Before Bind</h3>
<pre><code class="lang-csharp">// ✅ Good - Validate all at once
var result = Email.TryCreate(email)
    .Combine(FirstName.TryCreate(firstName))
    .Combine(LastName.TryCreate(lastName))
    .Bind((e, f, l) =&gt; CreateUser(e, f, l));

// ❌ Less efficient - Sequential validation
var result = Email.TryCreate(email)
    .Bind(e =&gt; FirstName.TryCreate(firstName)
        .Bind(f =&gt; LastName.TryCreate(lastName)
            .Bind(l =&gt; CreateUser(e, f, l))));
</code></pre>
<h3 id="4-minimize-allocations-in-hot-paths">4. Minimize Allocations in Hot Paths</h3>
<pre><code class="lang-csharp">// ✅ Good - Reuse error instances
private static readonly Error InvalidAgeError = 
    Error.Validation(&quot;Age must be between 0 and 120&quot;);

public Result&lt;Age&gt; ValidateAge(int age)
{
    return age is &gt;= 0 and &lt;= 120
        ? Result.Success(new Age(age))
        : InvalidAgeError;
}

// ❌ Allocates error on every failure
public Result&lt;Age&gt; ValidateAge(int age)
{
    return age is &gt;= 0 and &lt;= 120
        ? Result.Success(new Age(age))
        : Error.Validation(&quot;Age must be between 0 and 120&quot;);  // New allocation
}
</code></pre>
<h3 id="5-use-configureawait-in-libraries">5. Use ConfigureAwait in Libraries</h3>
<pre><code class="lang-csharp">// ✅ Good - For library code
public async Task&lt;Result&lt;User&gt;&gt; GetUserAsync(UserId id)
{
    var user = await _repository.GetByIdAsync(id).ConfigureAwait(false);
    return user.ToResult(Error.NotFound($&quot;User {id} not found&quot;));
}

// ✅ Also fine - For application code (ASP.NET Core)
public async Task&lt;Result&lt;User&gt;&gt; GetUserAsync(UserId id)
{
    var user = await _repository.GetByIdAsync(id);
    return user.ToResult(Error.NotFound($&quot;User {id} not found&quot;));
}
</code></pre>
<h3 id="6-avoid-excessive-logging-in-hot-paths">6. Avoid Excessive Logging in Hot Paths</h3>
<pre><code class="lang-csharp">// ❌ Bad - Logs on every success
.Tap(user =&gt; _logger.LogDebug(&quot;Got user {Id}&quot;, user.Id))

// ✅ Good - Log only on failures or important events
.TapOnFailure(error =&gt; _logger.LogWarning(&quot;Failed to get user: {Error}&quot;, error))

// ✅ Good - Use structured logging with guards
.Tap(user =&gt; 
{
    if (_logger.IsEnabled(LogLevel.Debug))
        _logger.LogDebug(&quot;Got user {Id}&quot;, user.Id);
})
</code></pre>
<h2 id="benefits-without-sacrifice">Benefits Without Sacrifice</h2>
<p>Despite the minimal overhead, you get significant benefits:</p>
<p>✅ <strong>Same Memory Usage</strong> - No additional allocations vs imperative code<br>
⚡ <strong>Blazing Fast</strong> - Single-digit to low double-digit nanosecond overhead<br>
✅ <strong>Better Code</strong> - Cleaner, more testable, and maintainable<br>
✅ <strong>Explicit Errors</strong> - Clear error propagation and aggregation<br>
✅ <strong>Composable</strong> - Chain operations naturally<br>
✅ <strong>Type Safe</strong> - Compiler-enforced error handling</p>
<h2 id="running-your-own-benchmarks">Running Your Own Benchmarks</h2>
<h3 id="install-benchmarkdotnet">Install BenchmarkDotNet</h3>
<pre><code class="lang-bash">dotnet add package BenchmarkDotNet
</code></pre>
<h3 id="create-a-benchmark">Create a Benchmark</h3>
<pre><code class="lang-csharp">using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using FunctionalDdd;

[MemoryDiagnoser]
[ShortRunJob]
public class MyBenchmarks
{
    [Benchmark]
    public Result&lt;int&gt; RopStyle()
    {
        return Result.Success(5)
            .Map(x =&gt; x * 2)
            .Ensure(x =&gt; x &gt; 0, Error.Validation(&quot;Must be positive&quot;))
            .Map(x =&gt; x + 10);
    }

    [Benchmark(Baseline = true)]
    public int ImperativeStyle()
    {
        var x = 5;
        x = x * 2;
        if (x &lt;= 0) throw new InvalidOperationException();
        return x + 10;
    }
}

// Run benchmarks
class Program
{
    static void Main(string[] args)
    {
        BenchmarkRunner.Run&lt;MyBenchmarks&gt;();
    }
}
</code></pre>
<h3 id="run-the-benchmark">Run the Benchmark</h3>
<pre><code class="lang-bash">dotnet run -c Release --project YourBenchmarkProject
</code></pre>
<h3 id="view-full-project-benchmarks">View Full Project Benchmarks</h3>
<pre><code class="lang-bash">cd FunctionalDDD
dotnet run --project Benchmark/Benchmark.csproj -c Release
</code></pre>
<h2 id="performance-faqs">Performance FAQs</h2>
<h3 id="q-is-rop-slower-than-exceptions">Q: Is ROP slower than exceptions?</h3>
<p><strong>A:</strong> For the error path, ROP is typically <strong>faster</strong> than exceptions:</p>
<ul>
<li>Exception throw: ~1,000-10,000 ns</li>
<li>ROP error return: ~90-150 ns</li>
</ul>
<h3 id="q-should-i-worry-about-the-16ns-overhead">Q: Should I worry about the 16ns overhead?</h3>
<p><strong>A:</strong> No, unless you're in a <strong>tight CPU-bound loop</strong>. For typical web applications with database/HTTP calls, the overhead is <strong>0.002%</strong> or less.</p>
<h3 id="q-what-about-memory-pressure">Q: What about memory pressure?</h3>
<p><strong>A:</strong> ROP has <strong>identical</strong> memory allocations to imperative code. The Result struct is stack-allocated in most cases.</p>
<h3 id="q-how-does-async-affect-performance">Q: How does async affect performance?</h3>
<p><strong>A:</strong> Async overhead comes from the Task machinery (~50-100 ns), not ROP. ROP adds the same ~15 ns overhead on top.</p>
<h3 id="q-can-i-use-rop-in-high-performance-scenarios">Q: Can I use ROP in high-performance scenarios?</h3>
<p><strong>A:</strong> Yes! The overhead is minimal. Many high-throughput systems use ROP successfully. Profile your specific use case if concerned.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/xavierjohn/FunctionalDDD/blob/main/docs/docfx_project/articles/performance.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
